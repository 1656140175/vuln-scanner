---
name: 平台集成功能
status: open
created: 2025-09-13T10:46:04Z
updated: 2025-09-13T10:46:04Z
github: [Will be updated when synced to GitHub]
depends_on: [006]
parallel: false
conflicts_with: []
---

# Task 007: 平台集成功能

## 概述
实现与主要合法漏洞赏金平台的集成功能，包括自动提交、状态跟踪和奖励管理。

## 技术要求

### 支持的平台
- HackerOne API集成
- Bugcrowd API集成  
- Intigriti API集成
- Open Bug Bounty集成
- 自定义平台适配器架构

### 核心功能实现

#### 1. 平台连接器模块
```python
# src/integrations/platform_connector.py
class PlatformConnector:
    """统一平台连接器接口"""
    
    def authenticate(self, credentials: Dict) -> bool:
        """平台认证"""
        pass
    
    def submit_vulnerability(self, vuln_data: VulnData) -> str:
        """提交漏洞报告"""
        pass
    
    def check_status(self, report_id: str) -> ReportStatus:
        """检查报告状态"""
        pass
    
    def get_rewards(self) -> List[Reward]:
        """获取奖励信息"""
        pass
```

#### 2. HackerOne集成
```python
# src/integrations/hackerone.py
class HackerOneConnector(PlatformConnector):
    """HackerOne平台集成"""
    
    BASE_URL = "https://api.hackerone.com/v1"
    
    def __init__(self, username: str, api_token: str):
        self.auth = (username, api_token)
        self.session = requests.Session()
    
    def authenticate(self) -> bool:
        """验证API凭证"""
        try:
            response = self.session.get(
                f"{self.BASE_URL}/me", 
                auth=self.auth
            )
            return response.status_code == 200
        except Exception:
            return False
    
    def submit_vulnerability(self, vuln_data: VulnData) -> str:
        """提交漏洞到HackerOne"""
        payload = {
            "data": {
                "type": "report",
                "attributes": {
                    "title": vuln_data.title,
                    "vulnerability_information": vuln_data.description,
                    "severity_rating": vuln_data.severity,
                    "structured_scope": vuln_data.scope
                }
            }
        }
        
        response = self.session.post(
            f"{self.BASE_URL}/reports",
            json=payload,
            auth=self.auth,
            headers={"Content-Type": "application/json"}
        )
        
        if response.status_code == 201:
            return response.json()["data"]["id"]
        else:
            raise PlatformError(f"Failed to submit: {response.text}")
```

#### 3. Bugcrowd集成
```python
# src/integrations/bugcrowd.py
class BugcrowdConnector(PlatformConnector):
    """Bugcrowd平台集成"""
    
    BASE_URL = "https://api.bugcrowd.com/v2"
    
    def __init__(self, email: str, password: str):
        self.credentials = {"email": email, "password": password}
        self.session = requests.Session()
        self.token = None
    
    def authenticate(self) -> bool:
        """登录获取访问令牌"""
        try:
            response = self.session.post(
                f"{self.BASE_URL}/user_sessions",
                json=self.credentials
            )
            
            if response.status_code == 200:
                self.token = response.json().get("token")
                self.session.headers.update({
                    "Authorization": f"Bearer {self.token}"
                })
                return True
            return False
        except Exception:
            return False
    
    def submit_vulnerability(self, vuln_data: VulnData) -> str:
        """提交漏洞到Bugcrowd"""
        if not self.token:
            raise PlatformError("Not authenticated")
        
        payload = {
            "title": vuln_data.title,
            "description": vuln_data.description,
            "severity": vuln_data.severity,
            "target": vuln_data.target,
            "proof_of_concept": vuln_data.poc
        }
        
        response = self.session.post(
            f"{self.BASE_URL}/submissions",
            json=payload
        )
        
        if response.status_code == 201:
            return response.json()["id"]
        else:
            raise PlatformError(f"Failed to submit: {response.text}")
```

#### 4. 平台管理器
```python
# src/integrations/platform_manager.py
class PlatformManager:
    """平台集成管理器"""
    
    def __init__(self, config_path: str = "config/platforms.yaml"):
        self.config = self.load_config(config_path)
        self.connectors = {}
        self.initialize_connectors()
    
    def initialize_connectors(self):
        """初始化平台连接器"""
        for platform_name, config in self.config.items():
            if config.get("enabled", False):
                connector_class = self.get_connector_class(platform_name)
                self.connectors[platform_name] = connector_class(**config["credentials"])
    
    def get_connector_class(self, platform_name: str) -> Type[PlatformConnector]:
        """获取平台连接器类"""
        mapping = {
            "hackerone": HackerOneConnector,
            "bugcrowd": BugcrowdConnector,
            "intigriti": IntigritiConnector,
            "openbugbounty": OpenBugBountyConnector
        }
        return mapping.get(platform_name.lower())
    
    async def submit_to_all_platforms(self, vuln_data: VulnData) -> Dict[str, str]:
        """向所有启用的平台提交漏洞"""
        results = {}
        
        for platform_name, connector in self.connectors.items():
            try:
                if connector.authenticate():
                    report_id = connector.submit_vulnerability(vuln_data)
                    results[platform_name] = {
                        "status": "success",
                        "report_id": report_id
                    }
                    logger.info(f"Successfully submitted to {platform_name}: {report_id}")
                else:
                    results[platform_name] = {
                        "status": "error",
                        "error": "Authentication failed"
                    }
            except Exception as e:
                results[platform_name] = {
                    "status": "error", 
                    "error": str(e)
                }
                logger.error(f"Failed to submit to {platform_name}: {e}")
        
        return results
    
    async def track_submissions(self) -> Dict[str, List[ReportStatus]]:
        """跟踪所有提交状态"""
        tracking_results = {}
        
        for platform_name, connector in self.connectors.items():
            try:
                # 从数据库获取该平台的所有报告ID
                report_ids = await self.get_platform_reports(platform_name)
                statuses = []
                
                for report_id in report_ids:
                    status = connector.check_status(report_id)
                    statuses.append(status)
                
                tracking_results[platform_name] = statuses
            except Exception as e:
                logger.error(f"Failed to track {platform_name}: {e}")
        
        return tracking_results
```

#### 5. 数据模型
```python
# src/models/integration_models.py
@dataclass
class VulnData:
    """漏洞数据模型"""
    title: str
    description: str
    severity: str  # low, medium, high, critical
    target: str
    poc: str  # Proof of Concept
    scope: Dict
    cvss_score: float
    cwe_id: str
    attachments: List[str] = None

@dataclass  
class ReportStatus:
    """报告状态模型"""
    report_id: str
    platform: str
    status: str  # submitted, triaged, resolved, duplicate, etc.
    last_updated: datetime
    bounty_amount: Optional[float] = None
    feedback: Optional[str] = None

@dataclass
class Reward:
    """奖励模型"""
    platform: str
    report_id: str
    amount: float
    currency: str
    date_awarded: datetime
    vulnerability_type: str
```

#### 6. 配置管理
```yaml
# config/platforms.yaml
hackerone:
  enabled: true
  credentials:
    username: "${HACKERONE_USERNAME}"
    api_token: "${HACKERONE_API_TOKEN}"
  rate_limit: 60  # requests per hour
  retry_config:
    max_retries: 3
    backoff_factor: 2

bugcrowd:
  enabled: true
  credentials:
    email: "${BUGCROWD_EMAIL}"
    password: "${BUGCROWD_PASSWORD}"
  rate_limit: 100
  retry_config:
    max_retries: 3
    backoff_factor: 2

intigriti:
  enabled: false
  credentials:
    api_key: "${INTIGRITI_API_KEY}"
    secret: "${INTIGRITI_SECRET}"

openbugbounty:
  enabled: true
  credentials:
    username: "${OBB_USERNAME}"
    password: "${OBB_PASSWORD}"
```

#### 7. 报告生成
```python
# src/integrations/report_generator.py
class ReportGenerator:
    """自动化报告生成器"""
    
    def __init__(self, template_dir: str = "templates/reports"):
        self.template_env = jinja2.Environment(
            loader=jinja2.FileSystemLoader(template_dir)
        )
    
    def generate_report(self, vuln_data: VulnData, platform: str) -> str:
        """根据平台生成定制化报告"""
        template_name = f"{platform}_template.md"
        template = self.template_env.get_template(template_name)
        
        return template.render(
            title=vuln_data.title,
            description=vuln_data.description,
            severity=vuln_data.severity,
            target=vuln_data.target,
            poc=vuln_data.poc,
            cvss_score=vuln_data.cvss_score,
            cwe_id=vuln_data.cwe_id,
            timestamp=datetime.now().isoformat()
        )
    
    def create_poc_package(self, vuln_data: VulnData) -> str:
        """创建PoC包"""
        package_dir = f"output/poc_packages/{vuln_data.title.replace(' ', '_')}"
        os.makedirs(package_dir, exist_ok=True)
        
        # 生成主报告文件
        report_content = self.generate_report(vuln_data, "generic")
        with open(f"{package_dir}/report.md", "w") as f:
            f.write(report_content)
        
        # 复制相关附件
        if vuln_data.attachments:
            for attachment in vuln_data.attachments:
                shutil.copy(attachment, package_dir)
        
        # 创建压缩包
        zip_path = f"{package_dir}.zip"
        with zipfile.ZipFile(zip_path, 'w') as zipf:
            for root, dirs, files in os.walk(package_dir):
                for file in files:
                    zipf.write(os.path.join(root, file), file)
        
        return zip_path
```

## 实现步骤

1. **设计平台连接器架构** (6小时)
   - 定义统一接口
   - 实现基础连接器类
   - 设计错误处理机制

2. **实现主要平台集成** (12小时)
   - HackerOne API集成
   - Bugcrowd API集成
   - API认证和请求处理

3. **开发平台管理器** (8小时)
   - 多平台统一管理
   - 配置文件处理
   - 并发提交处理

4. **实现报告生成器** (6小时)
   - 模板化报告生成
   - PoC包创建
   - 平台定制化格式

5. **测试和优化** (4小时)
   - 单元测试
   - 集成测试
   - 性能优化

## 验收标准

- [ ] 成功集成至少2个主要赏金平台
- [ ] 自动化漏洞提交功能正常
- [ ] 报告状态跟踪准确
- [ ] 错误处理健壮
- [ ] 配置管理灵活
- [ ] 测试覆盖率 > 90%

## 预估工作量
**总计: 2.5天 (36小时)**

## 注意事项
- 严格遵守各平台API使用条款
- 实现适当的速率限制
- 确保敏感信息安全存储
- 提供详细的错误日志
- 支持重试和恢复机制