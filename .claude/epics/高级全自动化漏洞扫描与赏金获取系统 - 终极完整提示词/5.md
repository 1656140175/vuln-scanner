---
name: 跨平台兼容
status: open
created: 2025-09-13T10:46:04Z
updated: 2025-09-13T10:46:04Z
github: [Will be updated when synced to GitHub]
depends_on: [001]
parallel: true
conflicts_with: []
---

# Task 008: 跨平台兼容

## 概述
实现系统在Windows本地环境和Google Colab云环境的完全兼容性，确保无缝部署和运行。

## 技术要求

### 支持平台
- Windows 10/11 本地环境
- Google Colab 云环境
- Linux (Ubuntu/Debian) 支持
- 容器化部署 (Docker)

### 核心功能实现

#### 1. 平台检测模块
```python
# src/utils/platform_detector.py
import platform
import sys
import os
from enum import Enum
from dataclasses import dataclass
from typing import Dict, Any, Optional

class PlatformType(Enum):
    WINDOWS = "windows"
    COLAB = "colab"
    LINUX = "linux"
    DOCKER = "docker"
    UNKNOWN = "unknown"

@dataclass
class PlatformInfo:
    """平台信息数据类"""
    platform_type: PlatformType
    os_name: str
    os_version: str
    python_version: str
    is_gpu_available: bool
    available_memory: int  # MB
    cpu_count: int
    is_notebook: bool
    working_directory: str
    temp_directory: str

class PlatformDetector:
    """平台检测器"""
    
    @staticmethod
    def detect() -> PlatformInfo:
        """检测当前运行平台"""
        platform_type = PlatformDetector._detect_platform_type()
        
        return PlatformInfo(
            platform_type=platform_type,
            os_name=platform.system(),
            os_version=platform.version(),
            python_version=sys.version,
            is_gpu_available=PlatformDetector._check_gpu_availability(),
            available_memory=PlatformDetector._get_available_memory(),
            cpu_count=os.cpu_count(),
            is_notebook=PlatformDetector._is_running_in_notebook(),
            working_directory=os.getcwd(),
            temp_directory=PlatformDetector._get_temp_directory()
        )
    
    @staticmethod
    def _detect_platform_type() -> PlatformType:
        """检测平台类型"""
        # 检测Google Colab
        try:
            import google.colab
            return PlatformType.COLAB
        except ImportError:
            pass
        
        # 检测Docker
        if os.path.exists('/.dockerenv'):
            return PlatformType.DOCKER
        
        # 检测操作系统
        system = platform.system().lower()
        if system == 'windows':
            return PlatformType.WINDOWS
        elif system in ['linux', 'darwin']:
            return PlatformType.LINUX
        
        return PlatformType.UNKNOWN
    
    @staticmethod
    def _check_gpu_availability() -> bool:
        """检查GPU可用性"""
        try:
            import torch
            return torch.cuda.is_available()
        except ImportError:
            try:
                import tensorflow as tf
                return len(tf.config.experimental.list_physical_devices('GPU')) > 0
            except ImportError:
                return False
    
    @staticmethod
    def _get_available_memory() -> int:
        """获取可用内存(MB)"""
        try:
            import psutil
            return psutil.virtual_memory().available // (1024 * 1024)
        except ImportError:
            return 0
    
    @staticmethod
    def _is_running_in_notebook() -> bool:
        """检查是否在Notebook环境中运行"""
        try:
            from IPython import get_ipython
            return get_ipython() is not None
        except ImportError:
            return False
    
    @staticmethod
    def _get_temp_directory() -> str:
        """获取临时目录"""
        import tempfile
        return tempfile.gettempdir()
```

#### 2. 配置适配器
```python
# src/utils/config_adapter.py
class ConfigAdapter:
    """平台特定配置适配器"""
    
    def __init__(self, platform_info: PlatformInfo):
        self.platform_info = platform_info
        self.config = self._load_platform_config()
    
    def _load_platform_config(self) -> Dict[str, Any]:
        """加载平台特定配置"""
        base_config = self._get_base_config()
        platform_config = self._get_platform_specific_config()
        
        # 合并配置
        return {**base_config, **platform_config}
    
    def _get_base_config(self) -> Dict[str, Any]:
        """获取基础配置"""
        return {
            "max_workers": min(self.platform_info.cpu_count, 4),
            "memory_limit_mb": min(self.platform_info.available_memory * 0.8, 8192),
            "temp_dir": self.platform_info.temp_directory,
            "log_level": "INFO",
            "enable_gpu": self.platform_info.is_gpu_available
        }
    
    def _get_platform_specific_config(self) -> Dict[str, Any]:
        """获取平台特定配置"""
        if self.platform_info.platform_type == PlatformType.COLAB:
            return self._get_colab_config()
        elif self.platform_info.platform_type == PlatformType.WINDOWS:
            return self._get_windows_config()
        elif self.platform_info.platform_type == PlatformType.LINUX:
            return self._get_linux_config()
        else:
            return {}
    
    def _get_colab_config(self) -> Dict[str, Any]:
        """Google Colab特定配置"""
        return {
            "output_dir": "/content/drive/MyDrive/vuln_miner_output",
            "data_dir": "/content/vuln_miner_data",
            "install_dependencies": True,
            "use_drive_mount": True,
            "session_timeout": 12 * 3600,  # 12 hours
            "auto_save_interval": 300,  # 5 minutes
            "memory_limit_mb": 12288,  # 12GB for Colab Pro
            "enable_widgets": True,
            "display_progress": True
        }
    
    def _get_windows_config(self) -> Dict[str, Any]:
        """Windows特定配置"""
        return {
            "output_dir": os.path.expanduser("~/Documents/vuln_miner_output"),
            "data_dir": os.path.expanduser("~/AppData/Local/vuln_miner"),
            "install_dependencies": False,
            "use_powershell": True,
            "path_separator": "\\",
            "enable_windows_defender_bypass": True,
            "max_path_length": 260
        }
    
    def _get_linux_config(self) -> Dict[str, Any]:
        """Linux特定配置"""
        return {
            "output_dir": os.path.expanduser("~/vuln_miner_output"),
            "data_dir": os.path.expanduser("~/.local/share/vuln_miner"),
            "install_dependencies": False,
            "use_apt_packages": True,
            "path_separator": "/",
            "enable_sudo": False
        }
```

#### 3. 依赖管理器
```python
# src/utils/dependency_manager.py
class DependencyManager:
    """跨平台依赖管理器"""
    
    def __init__(self, platform_info: PlatformInfo):
        self.platform_info = platform_info
        self.installed_packages = set()
    
    async def ensure_dependencies(self) -> bool:
        """确保所有依赖已安装"""
        required_packages = self._get_required_packages()
        
        for package_info in required_packages:
            if not await self._is_package_installed(package_info):
                success = await self._install_package(package_info)
                if not success:
                    logger.error(f"Failed to install {package_info['name']}")
                    return False
                    
        return True
    
    def _get_required_packages(self) -> List[Dict]:
        """获取所需包列表"""
        base_packages = [
            {"name": "requests", "version": ">=2.25.0"},
            {"name": "aiohttp", "version": ">=3.7.0"},
            {"name": "beautifulsoup4", "version": ">=4.9.0"},
            {"name": "lxml", "version": ">=4.6.0"},
            {"name": "selenium", "version": ">=4.0.0"},
            {"name": "numpy", "version": ">=1.21.0"},
            {"name": "pandas", "version": ">=1.3.0"},
            {"name": "scikit-learn", "version": ">=1.0.0"}
        ]
        
        # 平台特定包
        if self.platform_info.platform_type == PlatformType.COLAB:
            base_packages.extend([
                {"name": "google-colab", "version": ">=1.0.0"},
                {"name": "ipywidgets", "version": ">=7.6.0"}
            ])
        elif self.platform_info.platform_type == PlatformType.WINDOWS:
            base_packages.extend([
                {"name": "pywin32", "version": ">=227", "platform": "windows"},
                {"name": "wmi", "version": ">=1.5.1", "platform": "windows"}
            ])
        
        return base_packages
    
    async def _install_package(self, package_info: Dict) -> bool:
        """安装包"""
        try:
            if self.platform_info.platform_type == PlatformType.COLAB:
                return await self._install_colab_package(package_info)
            else:
                return await self._install_pip_package(package_info)
        except Exception as e:
            logger.error(f"Error installing {package_info['name']}: {e}")
            return False
    
    async def _install_colab_package(self, package_info: Dict) -> bool:
        """在Colab中安装包"""
        import subprocess
        import sys
        
        cmd = [sys.executable, "-m", "pip", "install", 
               f"{package_info['name']}{package_info.get('version', '')}"]
        
        process = await asyncio.create_subprocess_exec(
            *cmd,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE
        )
        
        stdout, stderr = await process.communicate()
        return process.returncode == 0
```

#### 4. 文件系统适配器
```python
# src/utils/filesystem_adapter.py
class FileSystemAdapter:
    """跨平台文件系统适配器"""
    
    def __init__(self, platform_info: PlatformInfo):
        self.platform_info = platform_info
        self.path_separator = self._get_path_separator()
    
    def _get_path_separator(self) -> str:
        """获取路径分隔符"""
        return "\\" if self.platform_info.platform_type == PlatformType.WINDOWS else "/"
    
    def normalize_path(self, path: str) -> str:
        """规范化路径"""
        # 转换路径分隔符
        normalized = path.replace("/", self.path_separator).replace("\\", self.path_separator)
        
        # 处理Windows路径长度限制
        if self.platform_info.platform_type == PlatformType.WINDOWS:
            if len(normalized) > 260:
                # 使用长路径前缀
                if not normalized.startswith("\\\\?\\"):
                    normalized = "\\\\?\\" + os.path.abspath(normalized)
        
        return normalized
    
    def create_directory(self, path: str, mode: int = 0o755) -> bool:
        """创建目录"""
        try:
            normalized_path = self.normalize_path(path)
            os.makedirs(normalized_path, mode=mode, exist_ok=True)
            return True
        except Exception as e:
            logger.error(f"Failed to create directory {path}: {e}")
            return False
    
    def get_temp_file(self, suffix: str = "", prefix: str = "vuln_") -> str:
        """获取临时文件路径"""
        import tempfile
        fd, path = tempfile.mkstemp(suffix=suffix, prefix=prefix)
        os.close(fd)
        return self.normalize_path(path)
    
    def safe_file_write(self, path: str, content: str, encoding: str = "utf-8") -> bool:
        """安全文件写入"""
        try:
            normalized_path = self.normalize_path(path)
            
            # 确保目录存在
            directory = os.path.dirname(normalized_path)
            self.create_directory(directory)
            
            # 写入文件
            with open(normalized_path, 'w', encoding=encoding) as f:
                f.write(content)
            
            return True
        except Exception as e:
            logger.error(f"Failed to write file {path}: {e}")
            return False
```

#### 5. Colab特定工具
```python
# src/utils/colab_utils.py
class ColabUtils:
    """Google Colab专用工具"""
    
    @staticmethod
    def setup_colab_environment():
        """设置Colab环境"""
        if not ColabUtils.is_colab():
            return
        
        # 挂载Google Drive
        ColabUtils.mount_drive()
        
        # 设置显示选项
        ColabUtils.setup_display()
        
        # 安装系统依赖
        ColabUtils.install_system_dependencies()
    
    @staticmethod
    def is_colab() -> bool:
        """检查是否在Colab中运行"""
        try:
            import google.colab
            return True
        except ImportError:
            return False
    
    @staticmethod
    def mount_drive():
        """挂载Google Drive"""
        try:
            from google.colab import drive
            drive.mount('/content/drive')
            print("✓ Google Drive mounted successfully")
        except Exception as e:
            print(f"✗ Failed to mount Google Drive: {e}")
    
    @staticmethod
    def setup_display():
        """设置显示选项"""
        try:
            from IPython.display import HTML, display
            import pandas as pd
            
            # 设置pandas显示选项
            pd.set_option('display.max_columns', None)
            pd.set_option('display.width', None)
            pd.set_option('display.max_colwidth', 100)
            
            # 加载自定义CSS
            display(HTML("""
            <style>
            .progress-bar {
                width: 100%;
                height: 20px;
                background-color: #f0f0f0;
                border-radius: 10px;
                overflow: hidden;
            }
            .progress-fill {
                height: 100%;
                background-color: #4CAF50;
                transition: width 0.3s ease;
            }
            </style>
            """))
            
            print("✓ Display settings configured")
        except Exception as e:
            print(f"✗ Failed to setup display: {e}")
    
    @staticmethod
    def install_system_dependencies():
        """安装系统依赖"""
        dependencies = [
            "chromium-browser",
            "chromium-chromedriver",
            "fonts-liberation",
            "libasound2",
            "libatk-bridge2.0-0",
            "libdrm2",
            "libgtk-3-0",
            "libnspr4",
            "libnss3",
            "libxss1",
            "libxtst6",
            "xdg-utils"
        ]
        
        try:
            import subprocess
            subprocess.run(["apt-get", "update"], check=True, capture_output=True)
            subprocess.run(["apt-get", "install", "-y"] + dependencies, 
                         check=True, capture_output=True)
            print("✓ System dependencies installed")
        except Exception as e:
            print(f"✗ Failed to install system dependencies: {e}")
    
    @staticmethod
    def create_progress_bar(total: int, description: str = "Progress"):
        """创建进度条"""
        try:
            from IPython.display import HTML, display
            import uuid
            
            bar_id = f"progress_{uuid.uuid4().hex[:8]}"
            
            html = f"""
            <div style="margin: 10px 0;">
                <div style="font-weight: bold; margin-bottom: 5px;">{description}</div>
                <div class="progress-bar">
                    <div id="{bar_id}" class="progress-fill" style="width: 0%;"></div>
                </div>
                <div id="{bar_id}_text" style="margin-top: 5px;">0 / {total}</div>
            </div>
            """
            
            display(HTML(html))
            return bar_id
        except Exception:
            return None
    
    @staticmethod
    def update_progress_bar(bar_id: str, current: int, total: int):
        """更新进度条"""
        if not bar_id:
            return
        
        try:
            from IPython.display import Javascript, display
            
            percentage = (current / total) * 100
            
            js_code = f"""
            document.getElementById('{bar_id}').style.width = '{percentage}%';
            document.getElementById('{bar_id}_text').innerHTML = '{current} / {total} ({percentage:.1f}%)';
            """
            
            display(Javascript(js_code))
        except Exception:
            pass
```

#### 6. Windows特定工具
```python
# src/utils/windows_utils.py
class WindowsUtils:
    """Windows专用工具"""
    
    @staticmethod
    def is_admin() -> bool:
        """检查是否以管理员权限运行"""
        try:
            import ctypes
            return ctypes.windll.shell32.IsUserAnAdmin()
        except Exception:
            return False
    
    @staticmethod
    def get_system_info() -> Dict[str, Any]:
        """获取Windows系统信息"""
        try:
            import wmi
            c = wmi.WMI()
            
            system_info = {}
            
            # 获取操作系统信息
            for os_info in c.Win32_OperatingSystem():
                system_info.update({
                    'os_name': os_info.Name,
                    'os_version': os_info.Version,
                    'total_memory': int(os_info.TotalVisibleMemorySize) * 1024,
                    'available_memory': int(os_info.FreePhysicalMemory) * 1024
                })
            
            # 获取CPU信息
            for cpu_info in c.Win32_Processor():
                system_info.update({
                    'cpu_name': cpu_info.Name,
                    'cpu_cores': cpu_info.NumberOfCores,
                    'cpu_threads': cpu_info.NumberOfLogicalProcessors
                })
                break
            
            return system_info
        except Exception as e:
            logger.error(f"Failed to get Windows system info: {e}")
            return {}
    
    @staticmethod
    def setup_windows_environment():
        """设置Windows环境"""
        try:
            # 设置控制台编码
            import sys
            if sys.platform == 'win32':
                import codecs
                sys.stdout = codecs.getwriter('utf-8')(sys.stdout.buffer)
                sys.stderr = codecs.getwriter('utf-8')(sys.stderr.buffer)
            
            # 设置环境变量
            os.environ['PYTHONIOENCODING'] = 'utf-8'
            
            print("✓ Windows environment configured")
        except Exception as e:
            print(f"✗ Failed to setup Windows environment: {e}")
    
    @staticmethod
    def bypass_windows_defender(directory: str):
        """添加Windows Defender排除项"""
        try:
            import subprocess
            
            # 使用PowerShell添加排除项
            cmd = [
                "powershell", "-Command",
                f"Add-MpPreference -ExclusionPath '{directory}'"
            ]
            
            subprocess.run(cmd, check=True, capture_output=True)
            print(f"✓ Added Windows Defender exclusion for {directory}")
        except Exception as e:
            print(f"✗ Failed to add Windows Defender exclusion: {e}")
```

#### 7. 统一初始化器
```python
# src/core/platform_initializer.py
class PlatformInitializer:
    """平台初始化器"""
    
    def __init__(self):
        self.platform_info = PlatformDetector.detect()
        self.config_adapter = ConfigAdapter(self.platform_info)
        self.filesystem_adapter = FileSystemAdapter(self.platform_info)
        self.dependency_manager = DependencyManager(self.platform_info)
    
    async def initialize(self) -> bool:
        """初始化平台环境"""
        try:
            print(f"Initializing on {self.platform_info.platform_type.value} platform...")
            
            # 1. 平台特定设置
            await self._setup_platform_specific()
            
            # 2. 创建必要目录
            self._create_directories()
            
            # 3. 安装依赖
            if not await self.dependency_manager.ensure_dependencies():
                return False
            
            # 4. 验证环境
            if not self._validate_environment():
                return False
            
            print("✓ Platform initialization completed successfully")
            return True
            
        except Exception as e:
            print(f"✗ Platform initialization failed: {e}")
            return False
    
    async def _setup_platform_specific(self):
        """平台特定设置"""
        if self.platform_info.platform_type == PlatformType.COLAB:
            ColabUtils.setup_colab_environment()
        elif self.platform_info.platform_type == PlatformType.WINDOWS:
            WindowsUtils.setup_windows_environment()
    
    def _create_directories(self):
        """创建必要目录"""
        config = self.config_adapter.config
        
        directories = [
            config.get('output_dir'),
            config.get('data_dir'),
            config.get('temp_dir'),
            os.path.join(config.get('output_dir', ''), 'logs'),
            os.path.join(config.get('output_dir', ''), 'reports'),
            os.path.join(config.get('output_dir', ''), 'screenshots')
        ]
        
        for directory in directories:
            if directory:
                self.filesystem_adapter.create_directory(directory)
    
    def _validate_environment(self) -> bool:
        """验证环境"""
        required_checks = [
            self._check_python_version(),
            self._check_memory_requirements(),
            self._check_disk_space(),
            self._check_network_connectivity()
        ]
        
        return all(required_checks)
    
    def _check_python_version(self) -> bool:
        """检查Python版本"""
        major, minor = sys.version_info[:2]
        if major >= 3 and minor >= 8:
            print(f"✓ Python {major}.{minor} is supported")
            return True
        else:
            print(f"✗ Python {major}.{minor} is not supported (requires 3.8+)")
            return False
    
    def _check_memory_requirements(self) -> bool:
        """检查内存要求"""
        min_memory_mb = 2048  # 2GB minimum
        available_mb = self.platform_info.available_memory
        
        if available_mb >= min_memory_mb:
            print(f"✓ Memory check passed ({available_mb}MB available)")
            return True
        else:
            print(f"✗ Insufficient memory ({available_mb}MB < {min_memory_mb}MB required)")
            return False
    
    def _check_disk_space(self) -> bool:
        """检查磁盘空间"""
        try:
            import shutil
            _, _, free = shutil.disk_usage(self.platform_info.working_directory)
            free_gb = free // (1024**3)
            
            min_space_gb = 5  # 5GB minimum
            
            if free_gb >= min_space_gb:
                print(f"✓ Disk space check passed ({free_gb}GB available)")
                return True
            else:
                print(f"✗ Insufficient disk space ({free_gb}GB < {min_space_gb}GB required)")
                return False
        except Exception:
            print("⚠ Could not check disk space")
            return True
    
    def _check_network_connectivity(self) -> bool:
        """检查网络连接"""
        try:
            import urllib.request
            urllib.request.urlopen('http://www.google.com', timeout=5)
            print("✓ Network connectivity check passed")
            return True
        except Exception:
            print("✗ Network connectivity check failed")
            return False
```

## 实现步骤

1. **实现平台检测** (4小时)
   - 开发平台检测逻辑
   - 收集系统信息
   - 定义平台数据模型

2. **开发配置适配器** (6小时)
   - 实现平台特定配置
   - 处理路径和环境差异
   - 配置文件管理

3. **实现文件系统适配器** (4小时)
   - 路径规范化
   - 跨平台文件操作
   - 权限处理

4. **开发平台工具集** (8小时)
   - Colab专用工具
   - Windows专用工具
   - 依赖管理器

5. **集成和测试** (4小时)
   - 平台初始化器
   - 集成测试
   - 兼容性验证

## 验收标准

- [ ] Windows 10/11 完全支持
- [ ] Google Colab 完全支持
- [ ] Linux 基础支持
- [ ] 自动平台检测准确
- [ ] 配置自适应正确
- [ ] 依赖自动安装成功
- [ ] 测试覆盖率 > 85%

## 预估工作量
**总计: 1.5天 (26小时)**

## 注意事项
- 确保在所有平台上的用户体验一致
- 处理平台特定的限制和约束
- 提供详细的平台兼容性文档
- 实现优雅的降级机制
- 考虑不同平台的性能差异