---
name: 工具生命周期管理
status: open
created: 2025-09-13T10:46:04Z
updated: 2025-09-13T10:46:04Z
github: [Will be updated when synced to GitHub]
depends_on: [001]
parallel: false
conflicts_with: []
---

# Task 002: 工具生命周期管理

## 概述
构建统一的安全工具管理系统，负责工具的安装、更新、版本控制、依赖管理和运行时监控。支持主流安全工具如nmap, nuclei, gobuster等的自动化管理。

## 技术实现要求

### 1. 工具抽象接口设计

```python
from abc import ABC, abstractmethod
from typing import Dict, List, Any, Optional
from enum import Enum
import asyncio
from dataclasses import dataclass

class ToolStatus(Enum):
    NOT_INSTALLED = "not_installed"
    INSTALLING = "installing"
    INSTALLED = "installed"
    UPDATING = "updating"
    OUTDATED = "outdated"
    ERROR = "error"

@dataclass
class ToolInfo:
    name: str
    version: str
    path: str
    config: Dict[str, Any]
    status: ToolStatus
    last_updated: str
    dependencies: List[str]

class SecurityTool(ABC):
    def __init__(self, name: str, config: Dict[str, Any]):
        self.name = name
        self.config = config
        self.status = ToolStatus.NOT_INSTALLED
        
    @abstractmethod
    async def install(self) -> bool:
        """安装工具"""
        pass
        
    @abstractmethod
    async def update(self) -> bool:
        """更新工具"""
        pass
        
    @abstractmethod
    async def check_version(self) -> Optional[str]:
        """检查工具版本"""
        pass
        
    @abstractmethod
    async def validate_installation(self) -> bool:
        """验证安装是否正确"""
        pass
        
    @abstractmethod
    async def execute(self, command: List[str], **kwargs) -> Dict[str, Any]:
        """执行工具命令"""
        pass
```

### 2. 具体工具实现

#### Nmap工具管理器
```python
import subprocess
import re
import os
from pathlib import Path

class NmapTool(SecurityTool):
    def __init__(self, config: Dict[str, Any]):
        super().__init__("nmap", config)
        self.binary_path = config.get('path', '/usr/bin/nmap')
        self.default_args = config.get('default_args', ['-sS', '-sV'])
        
    async def install(self) -> bool:
        """安装nmap"""
        try:
            # 检查是否已安装
            if await self.validate_installation():
                self.status = ToolStatus.INSTALLED
                return True
                
            self.status = ToolStatus.INSTALLING
            
            # 根据操作系统选择安装方式
            import platform
            system = platform.system().lower()
            
            if system == "linux":
                # Ubuntu/Debian
                if os.path.exists('/usr/bin/apt'):
                    result = await self._run_command(['sudo', 'apt', 'update'])
                    if result['returncode'] == 0:
                        result = await self._run_command(['sudo', 'apt', 'install', '-y', 'nmap'])
                # CentOS/RHEL
                elif os.path.exists('/usr/bin/yum'):
                    result = await self._run_command(['sudo', 'yum', 'install', '-y', 'nmap'])
                # Arch Linux
                elif os.path.exists('/usr/bin/pacman'):
                    result = await self._run_command(['sudo', 'pacman', '-S', '--noconfirm', 'nmap'])
                else:
                    raise Exception("Unsupported Linux distribution")
                    
            elif system == "darwin":  # macOS
                # 使用Homebrew安装
                result = await self._run_command(['brew', 'install', 'nmap'])
                
            elif system == "windows":
                # Windows需要手动安装或使用chocolatey
                result = await self._run_command(['choco', 'install', 'nmap', '-y'])
                
            if result['returncode'] == 0:
                self.status = ToolStatus.INSTALLED
                return await self.validate_installation()
            else:
                self.status = ToolStatus.ERROR
                return False
                
        except Exception as e:
            self.status = ToolStatus.ERROR
            raise Exception(f"Failed to install nmap: {str(e)}")
    
    async def check_version(self) -> Optional[str]:
        """检查nmap版本"""
        try:
            result = await self._run_command([self.binary_path, '--version'])
            if result['returncode'] == 0:
                # 解析版本信息
                version_match = re.search(r'Nmap version (\d+\.\d+)', result['stdout'])
                if version_match:
                    return version_match.group(1)
            return None
        except:
            return None
    
    async def validate_installation(self) -> bool:
        """验证nmap安装"""
        return (os.path.isfile(self.binary_path) and 
                os.access(self.binary_path, os.X_OK) and
                await self.check_version() is not None)
    
    async def execute(self, target: str, scan_type: str = "basic", **kwargs) -> Dict[str, Any]:
        """执行nmap扫描"""
        scan_profiles = {
            'basic': ['-sS', '-sV'],
            'full': ['-sS', '-sV', '-sC', '-O'],
            'fast': ['-T4', '-F'],
            'stealth': ['-sS', '-T1'],
            'udp': ['-sU'],
            'script': ['-sC']
        }
        
        args = [self.binary_path]
        args.extend(scan_profiles.get(scan_type, self.default_args))
        args.extend(kwargs.get('extra_args', []))
        args.append(target)
        
        # 设置超时
        timeout = kwargs.get('timeout', 300)
        
        try:
            result = await self._run_command(args, timeout=timeout)
            
            return {
                'tool': 'nmap',
                'target': target,
                'scan_type': scan_type,
                'returncode': result['returncode'],
                'stdout': result['stdout'],
                'stderr': result['stderr'],
                'command': ' '.join(args),
                'success': result['returncode'] == 0
            }
        except asyncio.TimeoutError:
            return {
                'tool': 'nmap',
                'target': target,
                'scan_type': scan_type,
                'error': f'Scan timed out after {timeout} seconds',
                'success': False
            }
    
    async def _run_command(self, cmd: List[str], timeout: int = 300) -> Dict[str, Any]:
        """执行系统命令"""
        process = await asyncio.create_subprocess_exec(
            *cmd,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE
        )
        
        try:
            stdout, stderr = await asyncio.wait_for(
                process.communicate(), 
                timeout=timeout
            )
            
            return {
                'returncode': process.returncode,
                'stdout': stdout.decode('utf-8', errors='ignore'),
                'stderr': stderr.decode('utf-8', errors='ignore')
            }
        except asyncio.TimeoutError:
            process.kill()
            await process.wait()
            raise
```

#### Nuclei工具管理器
```python
import json
from pathlib import Path

class NucleiTool(SecurityTool):
    def __init__(self, config: Dict[str, Any]):
        super().__init__("nuclei", config)
        self.binary_path = config.get('path', '/usr/local/bin/nuclei')
        self.templates_dir = Path(config.get('templates_dir', 'data/nuclei-templates'))
        
    async def install(self) -> bool:
        """安装nuclei"""
        try:
            if await self.validate_installation():
                self.status = ToolStatus.INSTALLED
                return True
                
            self.status = ToolStatus.INSTALLING
            
            # 使用Go安装nuclei
            install_cmd = [
                'go', 'install', '-v', 
                'github.com/projectdiscovery/nuclei/v2/cmd/nuclei@latest'
            ]
            
            result = await self._run_command(install_cmd)
            
            if result['returncode'] == 0:
                # 更新模板
                await self.update_templates()
                self.status = ToolStatus.INSTALLED
                return await self.validate_installation()
            else:
                self.status = ToolStatus.ERROR
                return False
                
        except Exception as e:
            self.status = ToolStatus.ERROR
            raise Exception(f"Failed to install nuclei: {str(e)}")
    
    async def update_templates(self) -> bool:
        """更新nuclei模板"""
        try:
            result = await self._run_command([
                self.binary_path, '-update-templates', '-update-directory', str(self.templates_dir)
            ])
            return result['returncode'] == 0
        except:
            return False
    
    async def check_version(self) -> Optional[str]:
        """检查nuclei版本"""
        try:
            result = await self._run_command([self.binary_path, '-version'])
            if result['returncode'] == 0:
                lines = result['stdout'].strip().split('\n')
                for line in lines:
                    if 'Current Version:' in line:
                        return line.split(':')[-1].strip()
            return None
        except:
            return None
    
    async def execute(self, target: str, severity: str = "medium", **kwargs) -> Dict[str, Any]:
        """执行nuclei扫描"""
        args = [self.binary_path]
        
        # 基本参数
        args.extend(['-target', target])
        args.extend(['-severity', severity])
        args.extend(['-json'])  # 输出JSON格式
        
        # 模板目录
        if self.templates_dir.exists():
            args.extend(['-t', str(self.templates_dir)])
        
        # 额外参数
        if kwargs.get('templates'):
            args.extend(['-t', kwargs['templates']])
        if kwargs.get('exclude_templates'):
            args.extend(['-exclude-templates', kwargs['exclude_templates']])
        if kwargs.get('rate_limit'):
            args.extend(['-rate-limit', str(kwargs['rate_limit'])])
        
        timeout = kwargs.get('timeout', 600)
        
        try:
            result = await self._run_command(args, timeout=timeout)
            
            # 解析JSON输出
            vulnerabilities = []
            if result['stdout']:
                for line in result['stdout'].strip().split('\n'):
                    if line.strip():
                        try:
                            vuln = json.loads(line)
                            vulnerabilities.append(vuln)
                        except json.JSONDecodeError:
                            continue
            
            return {
                'tool': 'nuclei',
                'target': target,
                'severity': severity,
                'returncode': result['returncode'],
                'vulnerabilities': vulnerabilities,
                'raw_output': result['stdout'],
                'stderr': result['stderr'],
                'success': result['returncode'] == 0
            }
            
        except asyncio.TimeoutError:
            return {
                'tool': 'nuclei',
                'target': target,
                'error': f'Scan timed out after {timeout} seconds',
                'success': False
            }
```

### 3. 工具管理器
```python
import asyncio
from typing import Dict, List
import sqlite3
from datetime import datetime, timedelta

class ToolManager:
    def __init__(self, config: Dict[str, Any], db_path: str = "data/tools.db"):
        self.config = config
        self.db_path = db_path
        self.tools: Dict[str, SecurityTool] = {}
        self.init_database()
        self.register_tools()
    
    def init_database(self):
        """初始化工具数据库"""
        conn = sqlite3.connect(self.db_path)
        conn.execute('''
            CREATE TABLE IF NOT EXISTS tools (
                name TEXT PRIMARY KEY,
                version TEXT,
                path TEXT,
                status TEXT,
                last_updated TEXT,
                config TEXT
            )
        ''')
        conn.commit()
        conn.close()
    
    def register_tools(self):
        """注册所有工具"""
        tool_configs = self.config.get('tools', {})
        
        # 注册nmap
        if 'nmap' in tool_configs:
            self.tools['nmap'] = NmapTool(tool_configs['nmap'])
        
        # 注册nuclei
        if 'nuclei' in tool_configs:
            self.tools['nuclei'] = NucleiTool(tool_configs['nuclei'])
    
    async def install_all(self) -> Dict[str, bool]:
        """安装所有工具"""
        results = {}
        for name, tool in self.tools.items():
            try:
                results[name] = await tool.install()
                self._save_tool_status(tool)
            except Exception as e:
                results[name] = False
                print(f"Failed to install {name}: {str(e)}")
        return results
    
    async def check_updates(self) -> Dict[str, bool]:
        """检查工具更新"""
        updates_available = {}
        for name, tool in self.tools.items():
            try:
                current_version = await tool.check_version()
                last_check = self._get_last_update_check(name)
                
                # 每日检查一次更新
                if not last_check or (datetime.now() - last_check).days >= 1:
                    updates_available[name] = await self._check_remote_version(tool)
                    self._save_update_check(name)
                else:
                    updates_available[name] = False
                    
            except Exception:
                updates_available[name] = False
        
        return updates_available
    
    async def get_tool(self, name: str) -> Optional[SecurityTool]:
        """获取工具实例"""
        tool = self.tools.get(name)
        if tool and tool.status != ToolStatus.INSTALLED:
            # 尝试验证安装
            if await tool.validate_installation():
                tool.status = ToolStatus.INSTALLED
            else:
                tool.status = ToolStatus.NOT_INSTALLED
        return tool
    
    def _save_tool_status(self, tool: SecurityTool):
        """保存工具状态到数据库"""
        conn = sqlite3.connect(self.db_path)
        conn.execute('''
            INSERT OR REPLACE INTO tools 
            (name, version, path, status, last_updated, config) 
            VALUES (?, ?, ?, ?, ?, ?)
        ''', (
            tool.name,
            asyncio.run(tool.check_version()) or 'unknown',
            tool.config.get('path', ''),
            tool.status.value,
            datetime.now().isoformat(),
            json.dumps(tool.config)
        ))
        conn.commit()
        conn.close()
```

### 4. 依赖管理系统
```python
class DependencyManager:
    def __init__(self):
        self.dependency_graph = {
            'nuclei': ['go'],
            'gobuster': ['go'],
            'subfinder': ['go'],
            'httpx': ['go'],
            'nmap': [],  # nmap没有特殊依赖
        }
    
    async def install_dependencies(self, tool_name: str) -> bool:
        """安装工具依赖"""
        deps = self.dependency_graph.get(tool_name, [])
        
        for dep in deps:
            if not await self._check_dependency(dep):
                if not await self._install_dependency(dep):
                    return False
        return True
    
    async def _check_dependency(self, dep_name: str) -> bool:
        """检查依赖是否已安装"""
        try:
            result = await asyncio.create_subprocess_exec(
                'which', dep_name,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            await result.communicate()
            return result.returncode == 0
        except:
            return False
    
    async def _install_dependency(self, dep_name: str) -> bool:
        """安装依赖"""
        installers = {
            'go': self._install_go,
            'python3': self._install_python3,
            'git': self._install_git,
        }
        
        installer = installers.get(dep_name)
        if installer:
            return await installer()
        return False
    
    async def _install_go(self) -> bool:
        """安装Go语言环境"""
        import platform
        system = platform.system().lower()
        
        try:
            if system == "linux":
                # 下载并安装Go
                commands = [
                    ['wget', 'https://golang.org/dl/go1.21.0.linux-amd64.tar.gz'],
                    ['sudo', 'tar', '-C', '/usr/local', '-xzf', 'go1.21.0.linux-amd64.tar.gz'],
                    ['echo', 'export PATH=$PATH:/usr/local/go/bin', '>>', '$HOME/.profile']
                ]
                
                for cmd in commands:
                    result = await self._run_command(cmd)
                    if result['returncode'] != 0:
                        return False
                return True
                
            elif system == "darwin":
                result = await self._run_command(['brew', 'install', 'go'])
                return result['returncode'] == 0
                
        except Exception:
            return False
```

## 实施计划

### 阶段1: 工具抽象层 (0.5天)
- 定义SecurityTool接口
- 实现基础工具管理器
- 创建数据库模式

### 阶段2: 核心工具实现 (1天)
- 实现Nmap工具管理器
- 实现Nuclei工具管理器
- 添加版本检查和更新功能

### 阶段3: 依赖管理 (0.5天)
- 实现依赖检查和安装
- 处理不同操作系统的差异
- 添加环境验证

### 阶段4: 高级功能 (0.5天)
- 添加工具状态监控
- 实现自动更新机制
- 创建工具使用统计

### 阶段5: 测试和优化 (0.5天)
- 单元测试覆盖
- 集成测试验证
- 性能优化

## 验收标准

1. **工具管理**: 所有支持的工具能够正确安装、更新和执行
2. **版本控制**: 能够检查和管理工具版本
3. **依赖处理**: 自动处理工具依赖关系
4. **状态监控**: 实时跟踪工具状态和健康度
5. **错误处理**: 优雅处理安装和执行错误

## 预计工期
**3天**

## 风险控制
- 权限控制：安装工具需要适当的系统权限
- 网络依赖：某些工具需要网络下载，需要处理网络失败
- 版本兼容：确保工具版本兼容性