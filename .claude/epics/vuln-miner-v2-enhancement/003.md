---
task_id: 003
title: "åŸºç¡€æµ‹è¯•æ¡†æ¶æ­å»º"
phase: 1
priority: high
estimated_effort: 1.5d
parallel: true
dependencies: ["001"]
assignee: "test-engineer"
tags: ["testing", "pytest", "coverage", "infrastructure"]
---

# Task 003: åŸºç¡€æµ‹è¯•æ¡†æ¶æ­å»º ğŸ§ª

## æ¦‚è¿°
å»ºç«‹å®Œæ•´çš„è‡ªåŠ¨åŒ–æµ‹è¯•åŸºç¡€è®¾æ–½ï¼ŒåŒ…æ‹¬å•å…ƒæµ‹è¯•ã€é›†æˆæµ‹è¯•ã€è¦†ç›–ç‡ç›‘æ§å’Œæµ‹è¯•æ•°æ®ç®¡ç†ï¼Œä¸ºVulnMiner v2æä¾›90%+çš„æµ‹è¯•è¦†ç›–ç‡ä¿éšœã€‚

## èƒŒæ™¯ä¸ç›®æ ‡
å½“å‰ç³»ç»Ÿç¼ºä¹å®Œæ•´çš„æµ‹è¯•æ¡†æ¶ï¼Œéœ€è¦å»ºç«‹ï¼š
1. **åˆ†å±‚æµ‹è¯•æ¶æ„**: å•å…ƒæµ‹è¯•ã€é›†æˆæµ‹è¯•ã€ç«¯åˆ°ç«¯æµ‹è¯•
2. **é«˜è¦†ç›–ç‡**: ç›®æ ‡90%+ä»£ç è¦†ç›–ç‡
3. **è‡ªåŠ¨åŒ–æ‰§è¡Œ**: CI/CDé›†æˆå’Œè‡ªåŠ¨åŒ–æµ‹è¯•
4. **æµ‹è¯•æ•°æ®ç®¡ç†**: Mockæ•°æ®å’Œæµ‹è¯•ç¯å¢ƒ

## æŠ€æœ¯æ¶æ„

### 1. æµ‹è¯•ç›®å½•ç»“æ„
```
vuln_scanner/tests/
â”œâ”€â”€ unit/                    # å•å…ƒæµ‹è¯•
â”‚   â”œâ”€â”€ core/               # æ ¸å¿ƒæ¨¡å—æµ‹è¯•
â”‚   â”‚   â”œâ”€â”€ test_config.py
â”‚   â”‚   â”œâ”€â”€ test_scanner.py
â”‚   â”‚   â””â”€â”€ test_ai.py
â”‚   â”œâ”€â”€ tools/              # å·¥å…·æ¨¡å—æµ‹è¯•
â”‚   â””â”€â”€ platforms/          # å¹³å°æ¨¡å—æµ‹è¯•
â”œâ”€â”€ integration/            # é›†æˆæµ‹è¯•
â”‚   â”œâ”€â”€ test_scan_pipeline.py
â”‚   â”œâ”€â”€ test_ai_integration.py
â”‚   â””â”€â”€ test_tool_chain.py
â”œâ”€â”€ e2e/                   # ç«¯åˆ°ç«¯æµ‹è¯•
â”‚   â”œâ”€â”€ test_full_scan.py
â”‚   â””â”€â”€ test_user_workflow.py
â”œâ”€â”€ fixtures/              # æµ‹è¯•æ•°æ®
â”‚   â”œâ”€â”€ configs/           # æµ‹è¯•é…ç½®æ–‡ä»¶
â”‚   â”œâ”€â”€ scan_results/      # æ¨¡æ‹Ÿæ‰«æç»“æœ
â”‚   â””â”€â”€ targets/           # æµ‹è¯•ç›®æ ‡æ•°æ®
â”œâ”€â”€ mocks/                 # Mockå¯¹è±¡
â”‚   â”œâ”€â”€ mock_tools.py
â”‚   â”œâ”€â”€ mock_ai.py
â”‚   â””â”€â”€ mock_platforms.py
â””â”€â”€ conftest.py           # pytesté…ç½®
```

### 2. æµ‹è¯•æŠ€æœ¯æ ˆ
- **æµ‹è¯•æ¡†æ¶**: pytest + pytest-asyncio
- **è¦†ç›–ç‡å·¥å…·**: coverage.py + pytest-cov
- **Mockæ¡†æ¶**: unittest.mock + pytest-mock
- **æµ‹è¯•æ•°æ®**: factory-boy + faker
- **å¹¶å‘æµ‹è¯•**: pytest-xdist
- **æŠ¥å‘Šç”Ÿæˆ**: pytest-html + allure

## å®æ–½æ­¥éª¤

### Step 1: æµ‹è¯•åŸºç¡€è®¾æ–½ (0.5å¤©)

#### 1.1 pytesté…ç½®
```python
# vuln_scanner/tests/conftest.py
import pytest
import asyncio
import tempfile
from pathlib import Path
from unittest.mock import AsyncMock, MagicMock

@pytest.fixture(scope="session")
def event_loop():
    """åˆ›å»ºäº‹ä»¶å¾ªç¯"""
    loop = asyncio.get_event_loop_policy().new_event_loop()
    yield loop
    loop.close()

@pytest.fixture
def temp_config_dir():
    """ä¸´æ—¶é…ç½®ç›®å½•"""
    with tempfile.TemporaryDirectory() as temp_dir:
        yield Path(temp_dir)

@pytest.fixture
def mock_config():
    """æ¨¡æ‹Ÿé…ç½®å¯¹è±¡"""
    from vuln_scanner.core.config.models import VulnMinerConfig, AIConfig
    
    config = VulnMinerConfig()
    config.ai = AIConfig(enabled=True, default_provider="mock")
    return config

@pytest.fixture
def mock_ai_provider():
    """æ¨¡æ‹ŸAIæä¾›å•†"""
    mock = AsyncMock()
    mock.analyze_vulnerability.return_value = {
        "severity": "high",
        "confidence": 0.95,
        "description": "Mock vulnerability analysis"
    }
    return mock

@pytest.fixture
def sample_scan_target():
    """ç¤ºä¾‹æ‰«æç›®æ ‡"""
    return {
        "url": "https://example.com",
        "type": "web",
        "scope": "subdomain"
    }
```

#### 1.2 æµ‹è¯•é…ç½®æ–‡ä»¶
```ini
# vuln_scanner/pytest.ini
[tool:pytest]
testpaths = tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*
addopts = 
    --verbose
    --tb=short
    --cov=vuln_scanner
    --cov-report=term-missing
    --cov-report=html:htmlcov
    --cov-report=xml:coverage.xml
    --cov-fail-under=90
    --asyncio-mode=auto
markers =
    unit: Unit tests
    integration: Integration tests
    e2e: End-to-end tests
    slow: Slow running tests
    network: Tests requiring network access
    ai: Tests involving AI providers
asyncio_mode = auto
```

### Step 2: æ ¸å¿ƒæ¨¡å—æµ‹è¯• (0.5å¤©)

#### 2.1 é…ç½®ç®¡ç†æµ‹è¯•
```python
# vuln_scanner/tests/unit/core/test_config.py
import pytest
import os
from pathlib import Path
from vuln_scanner.core.config import ConfigManager
from vuln_scanner.core.config.models import VulnMinerConfig

class TestConfigManager:
    """é…ç½®ç®¡ç†å™¨æµ‹è¯•"""
    
    def test_load_default_config(self):
        """æµ‹è¯•åŠ è½½é»˜è®¤é…ç½®"""
        config_manager = ConfigManager()
        config = config_manager.get_config()
        
        assert isinstance(config, VulnMinerConfig)
        assert config.ai.enabled is True
        assert len(config.ai.providers) > 0
    
    def test_env_var_substitution(self, monkeypatch, temp_config_dir):
        """æµ‹è¯•ç¯å¢ƒå˜é‡æ›¿æ¢"""
        # è®¾ç½®ç¯å¢ƒå˜é‡
        monkeypatch.setenv("TEST_API_KEY", "test-key-123")
        
        # åˆ›å»ºæµ‹è¯•é…ç½®
        config_content = """
        ai:
          providers:
            test:
              api_key: "${TEST_API_KEY}"
              base_url: "${TEST_BASE_URL:http://localhost:8080}"
        """
        
        config_file = temp_config_dir / "test.yml"
        config_file.write_text(config_content)
        
        config_manager = ConfigManager(str(config_file))
        config = config_manager.get_config()
        
        assert config.ai.providers["test"].api_key == "test-key-123"
        assert config.ai.providers["test"].base_url == "http://localhost:8080"
    
    def test_config_validation(self):
        """æµ‹è¯•é…ç½®éªŒè¯"""
        config_manager = ConfigManager()
        errors = config_manager.validate()
        
        # é»˜è®¤é…ç½®åº”è¯¥æ˜¯æœ‰æ•ˆçš„
        assert len(errors) == 0
    
    @pytest.mark.parametrize("provider,expected_error", [
        ("openai", "ç¼ºå°‘APIå¯†é’¥"),
        ("claude", "ç¼ºå°‘APIå¯†é’¥"),
    ])
    def test_ai_config_validation(self, provider, expected_error):
        """æµ‹è¯•AIé…ç½®éªŒè¯"""
        # æµ‹è¯•ç¼ºå°‘APIå¯†é’¥çš„æƒ…å†µ
        pass
```

#### 2.2 AIé›†æˆæµ‹è¯•
```python
# vuln_scanner/tests/unit/core/test_ai.py
import pytest
from unittest.mock import AsyncMock, patch
from vuln_scanner.core.ai import AIManager, OpenAIProvider

class TestAIManager:
    """AIç®¡ç†å™¨æµ‹è¯•"""
    
    @pytest.fixture
    def ai_manager(self, mock_config):
        """AIç®¡ç†å™¨å®ä¾‹"""
        return AIManager(mock_config.ai)
    
    @pytest.mark.asyncio
    async def test_provider_selection(self, ai_manager):
        """æµ‹è¯•AIæä¾›å•†é€‰æ‹©"""
        provider = ai_manager.get_provider("openai")
        assert provider is not None
    
    @pytest.mark.asyncio
    async def test_fallback_mechanism(self, ai_manager):
        """æµ‹è¯•æ•…éšœè½¬ç§»æœºåˆ¶"""
        # æ¨¡æ‹Ÿç¬¬ä¸€ä¸ªæä¾›å•†å¤±è´¥
        with patch.object(ai_manager.providers["openai"], "analyze", side_effect=Exception("API Error")):
            result = await ai_manager.analyze_findings([])
            # åº”è¯¥ä½¿ç”¨å¤‡ç”¨æä¾›å•†æˆ–ä¼ ç»Ÿåˆ†æ
            assert result is not None

class TestOpenAIProvider:
    """OpenAIæä¾›å•†æµ‹è¯•"""
    
    @pytest.mark.asyncio
    @patch("openai.ChatCompletion.acreate")
    async def test_vulnerability_analysis(self, mock_openai):
        """æµ‹è¯•æ¼æ´åˆ†æ"""
        # æ¨¡æ‹ŸOpenAIå“åº”
        mock_openai.return_value = {
            "choices": [{
                "message": {
                    "content": '{"severity": "high", "confidence": 0.95}'
                }
            }]
        }
        
        provider = OpenAIProvider(api_key="test", base_url="http://test")
        result = await provider.analyze_vulnerability({"type": "sql_injection"})
        
        assert result["severity"] == "high"
        assert result["confidence"] == 0.95
```

### Step 3: é›†æˆæµ‹è¯• (0.3å¤©)

#### 3.1 æ‰«ææµç¨‹é›†æˆæµ‹è¯•
```python
# vuln_scanner/tests/integration/test_scan_pipeline.py
import pytest
from vuln_scanner.core.scanner import ScanEngine
from vuln_scanner.core.config import ConfigManager

class TestScanPipeline:
    """æ‰«æç®¡é“é›†æˆæµ‹è¯•"""
    
    @pytest.fixture
    def scan_engine(self):
        """æ‰«æå¼•æ“å®ä¾‹"""
        config = ConfigManager().get_config()
        return ScanEngine(config)
    
    @pytest.mark.asyncio
    @pytest.mark.integration
    async def test_quick_scan_pipeline(self, scan_engine, sample_scan_target):
        """æµ‹è¯•å¿«é€Ÿæ‰«æç®¡é“"""
        result = await scan_engine.run_quick_scan(sample_scan_target)
        
        assert result is not None
        assert "findings" in result
        assert "metadata" in result
        assert result["status"] == "completed"
    
    @pytest.mark.asyncio
    @pytest.mark.integration
    @pytest.mark.slow
    async def test_comprehensive_scan_pipeline(self, scan_engine, sample_scan_target):
        """æµ‹è¯•å…¨é¢æ‰«æç®¡é“"""
        result = await scan_engine.run_comprehensive_scan(sample_scan_target)
        
        assert result is not None
        assert len(result["findings"]) >= 0
        assert result["scan_time"] > 0
```

### Step 4: æµ‹è¯•å·¥å…·å’ŒæŠ¥å‘Š (0.2å¤©)

#### 4.1 æµ‹è¯•è¿è¡Œè„šæœ¬
```python
# vuln_scanner/scripts/run_tests.py
#!/usr/bin/env python3
"""æµ‹è¯•è¿è¡Œè„šæœ¬"""
import sys
import subprocess
from pathlib import Path

def run_unit_tests():
    """è¿è¡Œå•å…ƒæµ‹è¯•"""
    cmd = ["python", "-m", "pytest", "tests/unit/", "-v", "--cov=vuln_scanner"]
    return subprocess.run(cmd).returncode

def run_integration_tests():
    """è¿è¡Œé›†æˆæµ‹è¯•"""
    cmd = ["python", "-m", "pytest", "tests/integration/", "-v", "-m", "integration"]
    return subprocess.run(cmd).returncode

def run_all_tests():
    """è¿è¡Œæ‰€æœ‰æµ‹è¯•"""
    cmd = ["python", "-m", "pytest", "tests/", "-v"]
    return subprocess.run(cmd).returncode

def generate_coverage_report():
    """ç”Ÿæˆè¦†ç›–ç‡æŠ¥å‘Š"""
    cmd = ["python", "-m", "coverage", "html", "--directory=htmlcov"]
    subprocess.run(cmd)
    print("ğŸ“Š è¦†ç›–ç‡æŠ¥å‘Šç”Ÿæˆå®Œæˆ: htmlcov/index.html")

if __name__ == "__main__":
    if len(sys.argv) > 1:
        test_type = sys.argv[1]
        if test_type == "unit":
            exit_code = run_unit_tests()
        elif test_type == "integration":
            exit_code = run_integration_tests()
        elif test_type == "all":
            exit_code = run_all_tests()
        else:
            print("âŒ æœªçŸ¥çš„æµ‹è¯•ç±»å‹ã€‚ä½¿ç”¨: unit, integration, all")
            sys.exit(1)
    else:
        exit_code = run_all_tests()
    
    if exit_code == 0:
        generate_coverage_report()
    
    sys.exit(exit_code)
```

#### 4.2 æµ‹è¯•æ•°æ®å·¥å‚
```python
# vuln_scanner/tests/factories.py
import factory
from faker import Faker
from vuln_scanner.core.models import ScanTarget, Finding, Vulnerability

fake = Faker()

class ScanTargetFactory(factory.Factory):
    """æ‰«æç›®æ ‡å·¥å‚"""
    class Meta:
        model = ScanTarget
    
    url = factory.LazyFunction(lambda: fake.url())
    target_type = "web"
    scope = "subdomain"

class FindingFactory(factory.Factory):
    """å‘ç°ç»“æœå·¥å‚"""
    class Meta:
        model = Finding
    
    title = factory.LazyFunction(lambda: fake.sentence())
    severity = factory.Iterator(["critical", "high", "medium", "low"])
    confidence = factory.LazyFunction(lambda: fake.pyfloat(min_value=0.1, max_value=1.0))
    description = factory.LazyFunction(lambda: fake.text())

class VulnerabilityFactory(factory.Factory):
    """æ¼æ´å·¥å‚"""
    class Meta:
        model = Vulnerability
    
    cve_id = factory.LazyFunction(lambda: f"CVE-{fake.year()}-{fake.random_int(1000, 9999)}")
    cvss_score = factory.LazyFunction(lambda: fake.pyfloat(min_value=0.0, max_value=10.0))
    category = factory.Iterator(["sql_injection", "xss", "csrf", "rce"])
```

## éªŒæ”¶æ ‡å‡†

### æµ‹è¯•è¦†ç›–ç‡éªŒæ”¶
- [ ] **å•å…ƒæµ‹è¯•è¦†ç›–ç‡**: â‰¥ 90%
- [ ] **é›†æˆæµ‹è¯•è¦†ç›–**: ä¸»è¦ä¸šåŠ¡æµç¨‹100%è¦†ç›–
- [ ] **å…³é”®è·¯å¾„æµ‹è¯•**: æ‰«ææµç¨‹ç«¯åˆ°ç«¯æµ‹è¯•
- [ ] **é”™è¯¯å¤„ç†æµ‹è¯•**: å¼‚å¸¸æƒ…å†µè¦†ç›–

### æµ‹è¯•è´¨é‡éªŒæ”¶
- [ ] **æµ‹è¯•é€Ÿåº¦**: å•å…ƒæµ‹è¯• < 30ç§’ï¼Œå…¨é‡æµ‹è¯• < 5åˆ†é’Ÿ
- [ ] **æµ‹è¯•ç¨³å®šæ€§**: è¿ç»­è¿è¡Œ10æ¬¡æ— éšæœºå¤±è´¥
- [ ] **æµ‹è¯•ç‹¬ç«‹æ€§**: æµ‹è¯•é—´æ— ä¾èµ–ï¼Œå¯å¹¶è¡Œæ‰§è¡Œ
- [ ] **Mockè´¨é‡**: å¤–éƒ¨ä¾èµ–100% Mock

### è‡ªåŠ¨åŒ–éªŒæ”¶
```bash
# è¿è¡Œæµ‹è¯•å¥—ä»¶
python scripts/run_tests.py all

# æ£€æŸ¥è¦†ç›–ç‡
coverage report --show-missing

# è¿è¡Œç‰¹å®šæ ‡è®°çš„æµ‹è¯•
pytest -m "unit and not slow"
pytest -m "integration"
pytest -m "ai"
```

## äº¤ä»˜ç‰©

### æµ‹è¯•åŸºç¡€è®¾æ–½
- [ ] pytesté…ç½®å’Œæ’ä»¶é›†æˆ
- [ ] æµ‹è¯•ç›®å½•ç»“æ„å’Œè§„èŒƒ
- [ ] Mockæ¡†æ¶å’Œæµ‹è¯•æ•°æ®å·¥å‚
- [ ] è¦†ç›–ç‡ç›‘æ§å’ŒæŠ¥å‘Šç”Ÿæˆ

### æµ‹è¯•ç”¨ä¾‹
- [ ] æ ¸å¿ƒæ¨¡å—å•å…ƒæµ‹è¯•ï¼ˆ90%+è¦†ç›–ç‡ï¼‰
- [ ] ä¸šåŠ¡æµç¨‹é›†æˆæµ‹è¯•
- [ ] AIé›†æˆæµ‹è¯•å’ŒMock
- [ ] é…ç½®ç®¡ç†æµ‹è¯•

### æµ‹è¯•å·¥å…·
- [ ] è‡ªåŠ¨åŒ–æµ‹è¯•è¿è¡Œè„šæœ¬
- [ ] æµ‹è¯•æ•°æ®ç”Ÿæˆå·¥å…·
- [ ] æµ‹è¯•æŠ¥å‘Šç”Ÿæˆå™¨
- [ ] CI/CDé›†æˆé…ç½®

### æ–‡æ¡£
- [ ] æµ‹è¯•æ¡†æ¶ä½¿ç”¨æŒ‡å—
- [ ] æµ‹è¯•ç¼–å†™è§„èŒƒ
- [ ] Mockå’Œæµ‹è¯•æ•°æ®æŒ‡å—
- [ ] æµ‹è¯•è°ƒè¯•æ‰‹å†Œ

## é£é™©ä¸ç¼“è§£

### æŠ€æœ¯é£é™©
1. **å¼‚æ­¥æµ‹è¯•å¤æ‚æ€§**: pytest-asyncioé…ç½®å’Œè°ƒè¯•å›°éš¾
   - **ç¼“è§£**: è¯¦ç»†çš„å¼‚æ­¥æµ‹è¯•ç¤ºä¾‹å’Œæ–‡æ¡£
   - **å·¥å…·**: ä½¿ç”¨pytest-asyncio autoæ¨¡å¼

2. **Mockå¤æ‚æ€§**: å¤æ‚ä¸šåŠ¡é€»è¾‘çš„Mockè®¾è®¡å›°éš¾
   - **ç¼“è§£**: åˆ†å±‚Mockç­–ç•¥ï¼Œä»ç®€å•åˆ°å¤æ‚
   - **æœ€ä½³å®è·µ**: Mockå¤–éƒ¨ä¾èµ–ï¼Œä¸Mockä¸šåŠ¡é€»è¾‘

### è´¨é‡é£é™©
1. **æµ‹è¯•ç»´æŠ¤æˆæœ¬**: æµ‹è¯•ä»£ç é‡å¯èƒ½è¶…è¿‡ä¸šåŠ¡ä»£ç 
   - **ç¼“è§£**: é‡ç‚¹æµ‹è¯•æ ¸å¿ƒä¸šåŠ¡é€»è¾‘
   - **ç­–ç•¥**: æµ‹è¯•é‡‘å­—å¡”åŸåˆ™ï¼Œæ›´å¤šå•å…ƒæµ‹è¯•

---
**ä»»åŠ¡è´Ÿè´£äºº**: Test Engineer  
**å®¡æ ¸äºº**: Tech Lead  
**ä¾èµ–ä»»åŠ¡**: Task 001 (ä»£ç ç›®å½•é‡æ„)  
**å¹¶è¡Œä»»åŠ¡**: Task 002 (é…ç½®ç®¡ç†ç³»ç»Ÿ)  
**é¢„è®¡å·¥ä½œé‡**: 1.5å¤©