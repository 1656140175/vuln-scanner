---
task_id: 005
title: "循环扫描模式与文件导入功能"
phase: 3
priority: high
estimated_effort: 2d
parallel: false
dependencies: ["001", "002"]
assignee: "backend-engineer"
tags: ["scanning", "user-experience", "interactive", "batch"]
---

# Task 005: 循环扫描模式与文件导入功能 🔄

## 概述
实现交互式循环扫描模式和批量文件导入功能，允许用户连续输入目标进行扫描，支持从文件导入目标列表，每次仅处理一个目标，提供优秀的用户体验。

## 背景与需求
当前scan模式只能单次扫描后退出，需要增强为：
1. **循环输入模式**: 用户可以连续输入多个目标
2. **单目标处理**: 每次仅处理一个目标，确保资源可控
3. **文件导入**: 支持从scan.txt等文件批量导入目标
4. **实时反馈**: 显示扫描进度和结果摘要

## 技术架构

### 1. 循环扫描器架构
```
InteractiveScanner (交互式扫描器)
├── InputManager (输入管理器)
│   ├── ConsoleInput (控制台输入)
│   ├── FileInput (文件输入) 
│   └── ValidationInput (输入验证)
├── ScanQueue (扫描队列)
│   ├── TargetQueue (目标队列)
│   ├── PriorityManager (优先级管理)
│   └── ProgressTracker (进度跟踪)
└── ResultPresenter (结果展示器)
    ├── RealTimeDisplay (实时显示)
    ├── SummaryReport (摘要报告)
    └── ExportManager (导出管理)
```

### 2. 支持的输入格式
- **控制台输入**: 交互式URL输入
- **TXT文件**: 每行一个URL
- **CSV文件**: 带元数据的目标列表
- **JSON文件**: 结构化目标配置

## 实施步骤

### Step 1: 输入管理器实现 (0.5天)

#### 1.1 输入验证器
```python
# vuln_scanner/core/scanner/input_validator.py
import re
import ipaddress
from urllib.parse import urlparse
from typing import List, Dict, Any, Optional
from dataclasses import dataclass

@dataclass
class TargetInfo:
    """目标信息"""
    url: str
    target_type: str  # url, ip, domain, cidr
    scope: str = "single"  # single, subdomain, full_domain
    priority: int = 1  # 1-5, 5最高
    metadata: Dict[str, Any] = None
    
    def __post_init__(self):
        if self.metadata is None:
            self.metadata = {}

class InputValidator:
    """输入验证器 - 验证和标准化扫描目标"""
    
    def __init__(self):
        self.url_pattern = re.compile(
            r'^https?://'  # http或https
            r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+[A-Z]{2,6}\.?|'  # 域名
            r'localhost|'  # localhost
            r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})'  # IP地址
            r'(?::\d+)?'  # 端口号
            r'(?:/?|[/?]\S+)$', re.IGNORECASE)
    
    def validate_input(self, input_text: str) -> Optional[TargetInfo]:
        """验证用户输入并返回标准化的目标信息"""
        input_text = input_text.strip()
        
        if not input_text:
            return None
        
        # 检查特殊命令
        if input_text.lower() in ['quit', 'exit', 'q']:
            return None
        
        # 检查文件导入命令
        if input_text.lower() in ['file', 'import', 'f']:
            return TargetInfo(url="__FILE_IMPORT__", target_type="file_import")
        
        # 验证URL格式
        target_info = self._parse_target(input_text)
        if target_info:
            return target_info
        
        print(f"❌ 无效的目标格式: {input_text}")
        print("支持的格式:")
        print("  - URL: https://example.com")
        print("  - IP: 192.168.1.1")
        print("  - 域名: example.com")
        print("  - CIDR: 192.168.1.0/24")
        print("  - 文件导入: file 或 import")
        print("  - 退出: quit 或 exit")
        return None
    
    def _parse_target(self, target: str) -> Optional[TargetInfo]:
        """解析目标字符串"""
        # URL格式
        if target.startswith(('http://', 'https://')):
            if self.url_pattern.match(target):
                return TargetInfo(url=target, target_type="url")
        
        # IP地址
        try:
            ipaddress.ip_address(target)
            return TargetInfo(url=f"http://{target}", target_type="ip")
        except ValueError:
            pass
        
        # CIDR网段
        try:
            ipaddress.ip_network(target, strict=False)
            return TargetInfo(url=target, target_type="cidr", scope="network")
        except ValueError:
            pass
        
        # 域名（添加http://前缀）
        if self._is_valid_domain(target):
            return TargetInfo(url=f"https://{target}", target_type="domain")
        
        return None
    
    def _is_valid_domain(self, domain: str) -> bool:
        """验证域名格式"""
        domain_pattern = re.compile(
            r'^(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)*[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?$'
        )
        return bool(domain_pattern.match(domain))
```

#### 1.2 文件导入器
```python
# vuln_scanner/core/scanner/file_importer.py
import csv
import json
from pathlib import Path
from typing import List, Dict, Any, Iterator
from .input_validator import TargetInfo, InputValidator

class FileImporter:
    """文件导入器 - 从文件批量导入扫描目标"""
    
    def __init__(self):
        self.validator = InputValidator()
        self.supported_formats = ['.txt', '.csv', '.json']
        self.max_file_size = 10 * 1024 * 1024  # 10MB
        self.max_targets = 1000
    
    def import_from_file(self, file_path: str) -> List[TargetInfo]:
        """从文件导入目标列表"""
        file_path = Path(file_path)
        
        # 验证文件
        if not file_path.exists():
            raise FileNotFoundError(f"文件不存在: {file_path}")
        
        if file_path.stat().st_size > self.max_file_size:
            raise ValueError(f"文件过大: {file_path.stat().st_size} bytes")
        
        if file_path.suffix.lower() not in self.supported_formats:
            raise ValueError(f"不支持的文件格式: {file_path.suffix}")
        
        # 根据文件类型导入
        if file_path.suffix.lower() == '.txt':
            return self._import_txt(file_path)
        elif file_path.suffix.lower() == '.csv':
            return self._import_csv(file_path)
        elif file_path.suffix.lower() == '.json':
            return self._import_json(file_path)
    
    def _import_txt(self, file_path: Path) -> List[TargetInfo]:
        """导入TXT文件"""
        targets = []
        
        with open(file_path, 'r', encoding='utf-8') as f:
            for line_num, line in enumerate(f, 1):
                line = line.strip()
                if not line or line.startswith('#'):  # 跳过空行和注释
                    continue
                
                target_info = self.validator.validate_input(line)
                if target_info:
                    targets.append(target_info)
                else:
                    print(f"⚠️ 跳过无效目标 (行 {line_num}): {line}")
                
                if len(targets) >= self.max_targets:
                    print(f"⚠️ 已达到最大目标数量限制: {self.max_targets}")
                    break
        
        return targets
    
    def _import_csv(self, file_path: Path) -> List[TargetInfo]:
        """导入CSV文件"""
        targets = []
        
        with open(file_path, 'r', encoding='utf-8') as f:
            reader = csv.DictReader(f)
            
            for row_num, row in enumerate(reader, 2):  # 从第2行开始（第1行是标题）
                url = row.get('url', '').strip()
                if not url:
                    continue
                
                target_info = self.validator.validate_input(url)
                if target_info:
                    # 添加CSV中的元数据
                    target_info.priority = int(row.get('priority', 1))
                    target_info.scope = row.get('scope', 'single')
                    target_info.metadata.update({
                        'description': row.get('description', ''),
                        'tags': row.get('tags', '').split(',') if row.get('tags') else []
                    })
                    targets.append(target_info)
                else:
                    print(f"⚠️ 跳过无效目标 (行 {row_num}): {url}")
                
                if len(targets) >= self.max_targets:
                    break
        
        return targets
    
    def _import_json(self, file_path: Path) -> List[TargetInfo]:
        """导入JSON文件"""
        with open(file_path, 'r', encoding='utf-8') as f:
            data = json.load(f)
        
        targets = []
        target_list = data.get('targets', []) if isinstance(data, dict) else data
        
        for item in target_list:
            if isinstance(item, str):
                target_info = self.validator.validate_input(item)
            elif isinstance(item, dict):
                url = item.get('url', '')
                target_info = self.validator.validate_input(url)
                if target_info:
                    target_info.priority = item.get('priority', 1)
                    target_info.scope = item.get('scope', 'single')
                    target_info.metadata.update(item.get('metadata', {}))
            else:
                continue
            
            if target_info:
                targets.append(target_info)
            
            if len(targets) >= self.max_targets:
                break
        
        return targets
```

### Step 2: 交互式扫描器核心 (1天)

#### 2.1 扫描队列管理
```python
# vuln_scanner/core/scanner/interactive_scanner.py
import asyncio
from typing import List, Optional, Dict, Any
from pathlib import Path
from .input_validator import InputValidator, TargetInfo
from .file_importer import FileImporter
from ..config.models import VulnMinerConfig

class InteractiveScanner:
    """交互式扫描器 - 支持循环输入和单目标处理"""
    
    def __init__(self, config: VulnMinerConfig):
        self.config = config
        self.validator = InputValidator()
        self.file_importer = FileImporter()
        self.scan_queue: List[TargetInfo] = []
        self.scan_results: List[Dict[str, Any]] = []
        self.running = False
        
    async def run_interactive_mode(self):
        """运行交互式扫描模式"""
        self.running = True
        
        print("🔍 VulnMiner 循环扫描模式")
        print("=" * 50)
        print("命令说明:")
        print("  • 输入目标URL进行扫描")
        print("  • 'file' 或 'import' - 从文件导入目标")
        print("  • 'queue' - 显示当前队列")
        print("  • 'results' - 显示扫描结果")
        print("  • 'quit' 或 'exit' - 退出程序")
        print("=" * 50)
        
        while self.running:
            try:
                # 显示队列状态
                if self.scan_queue:
                    print(f"\n📋 队列中有 {len(self.scan_queue)} 个目标待扫描")
                
                # 获取用户输入
                user_input = input("\n🎯 目标 > ").strip()
                
                if not user_input:
                    continue
                
                # 处理特殊命令
                if await self._handle_special_commands(user_input):
                    continue
                
                # 验证并添加目标
                target_info = self.validator.validate_input(user_input)
                if target_info:
                    if target_info.target_type == "file_import":
                        await self._handle_file_import()
                    else:
                        await self._add_target_to_queue(target_info)
                
            except KeyboardInterrupt:
                print("\n\n🛑 检测到 Ctrl+C，正在退出...")
                break
            except EOFError:
                print("\n👋 输入结束，退出程序")
                break
            except Exception as e:
                print(f"❌ 处理输入时发生错误: {e}")
        
        print("\n👋 感谢使用 VulnMiner!")
    
    async def _handle_special_commands(self, command: str) -> bool:
        """处理特殊命令"""
        command = command.lower()
        
        if command in ['quit', 'exit', 'q']:
            self.running = False
            return True
        
        elif command == 'queue':
            self._show_queue_status()
            return True
        
        elif command == 'results':
            self._show_scan_results()
            return True
        
        elif command == 'clear':
            self.scan_queue.clear()
            print("✅ 队列已清空")
            return True
        
        elif command == 'help':
            self._show_help()
            return True
        
        return False
    
    async def _add_target_to_queue(self, target_info: TargetInfo):
        """添加目标到队列并立即开始扫描"""
        print(f"📝 添加目标: {target_info.url}")
        
        # 立即扫描该目标（单目标处理）
        await self._scan_single_target(target_info)
    
    async def _scan_single_target(self, target_info: TargetInfo):
        """扫描单个目标"""
        print(f"\n🚀 开始扫描: {target_info.url}")
        print("=" * 60)
        
        try:
            # 这里调用实际的扫描引擎
            from ..scanning.scan_engine import ScanEngine
            
            scan_engine = ScanEngine(self.config)
            
            # 根据目标类型选择扫描管道
            if target_info.target_type in ['url', 'domain']:
                result = await scan_engine.run_web_scan(target_info.url)
            elif target_info.target_type == 'ip':
                result = await scan_engine.run_network_scan(target_info.url)
            elif target_info.target_type == 'cidr':
                result = await scan_engine.run_network_range_scan(target_info.url)
            else:
                result = await scan_engine.run_quick_scan(target_info.url)
            
            # 保存扫描结果
            scan_result = {
                'target': target_info.url,
                'type': target_info.target_type,
                'start_time': result.get('start_time'),
                'end_time': result.get('end_time'),
                'duration': result.get('duration'),
                'findings': result.get('findings', []),
                'status': result.get('status', 'completed'),
                'metadata': target_info.metadata
            }
            
            self.scan_results.append(scan_result)
            
            # 显示扫描摘要
            self._show_scan_summary(scan_result)
            
        except Exception as e:
            print(f"❌ 扫描失败: {e}")
            # 记录失败结果
            self.scan_results.append({
                'target': target_info.url,
                'status': 'failed',
                'error': str(e),
                'metadata': target_info.metadata
            })
    
    def _show_scan_summary(self, result: Dict[str, Any]):
        """显示扫描结果摘要"""
        print("\n📊 扫描结果摘要:")
        print("-" * 30)
        print(f"目标: {result['target']}")
        print(f"状态: {result['status']}")
        print(f"耗时: {result.get('duration', 0):.1f}秒")
        
        findings = result.get('findings', [])
        if findings:
            severity_counts = {}
            for finding in findings:
                severity = finding.get('severity', 'unknown')
                severity_counts[severity] = severity_counts.get(severity, 0) + 1
            
            print(f"发现问题: {len(findings)}个")
            for severity, count in severity_counts.items():
                print(f"  - {severity}: {count}个")
        else:
            print("✅ 未发现安全问题")
        
        print("-" * 30)
    
    async def _handle_file_import(self):
        """处理文件导入"""
        print("\n📁 文件导入模式")
        print("支持格式: .txt, .csv, .json")
        print("示例文件路径: scan.txt, targets.csv, config.json")
        
        file_path = input("📂 文件路径 > ").strip()
        
        if not file_path:
            print("❌ 未指定文件路径")
            return
        
        try:
            targets = self.file_importer.import_from_file(file_path)
            
            if not targets:
                print("❌ 文件中没有有效的目标")
                return
            
            print(f"✅ 成功导入 {len(targets)} 个目标")
            
            # 询问是否立即开始扫描
            confirm = input(f"是否立即开始扫描这 {len(targets)} 个目标? (y/N): ").strip().lower()
            
            if confirm in ['y', 'yes']:
                for i, target in enumerate(targets, 1):
                    print(f"\n[{i}/{len(targets)}] 扫描进度")
                    await self._scan_single_target(target)
                    
                    # 扫描间隔（避免过于频繁）
                    if i < len(targets):
                        await asyncio.sleep(2)
            else:
                self.scan_queue.extend(targets)
                print(f"✅ 已将 {len(targets)} 个目标添加到队列")
                
        except Exception as e:
            print(f"❌ 文件导入失败: {e}")
    
    def _show_queue_status(self):
        """显示队列状态"""
        if not self.scan_queue:
            print("📋 扫描队列为空")
            return
        
        print(f"\n📋 扫描队列 ({len(self.scan_queue)} 个目标):")
        print("-" * 50)
        for i, target in enumerate(self.scan_queue, 1):
            print(f"{i:2d}. {target.url} ({target.target_type})")
        print("-" * 50)
    
    def _show_scan_results(self):
        """显示扫描结果"""
        if not self.scan_results:
            print("📊 暂无扫描结果")
            return
        
        print(f"\n📊 扫描结果 ({len(self.scan_results)} 个):")
        print("-" * 60)
        
        for i, result in enumerate(self.scan_results, 1):
            status_icon = "✅" if result['status'] == 'completed' else "❌"
            findings_count = len(result.get('findings', []))
            
            print(f"{i:2d}. {status_icon} {result['target']}")
            if result['status'] == 'completed':
                print(f"    发现: {findings_count}个问题")
            else:
                print(f"    错误: {result.get('error', 'unknown')}")
        
        print("-" * 60)
    
    def _show_help(self):
        """显示帮助信息"""
        help_text = """
🔍 VulnMiner 交互式扫描帮助

支持的目标格式:
  • URL: https://example.com, http://test.com:8080
  • 域名: example.com (自动添加https://)
  • IP地址: 192.168.1.1 (自动添加http://)
  • 网段: 192.168.1.0/24

支持的命令:
  • file, import - 从文件导入目标
  • queue - 显示当前扫描队列
  • results - 显示扫描结果摘要
  • clear - 清空扫描队列
  • help - 显示此帮助信息
  • quit, exit - 退出程序

文件导入格式:
  • TXT: 每行一个URL
  • CSV: url,priority,scope,description
  • JSON: {"targets": ["url1", "url2"]}

扫描特点:
  • 单目标处理 - 每次仅扫描一个目标
  • 实时反馈 - 显示扫描进度和结果
  • 智能识别 - 自动识别目标类型
        """
        print(help_text)
```

## 验收标准

### 功能性验收
- [ ] **循环输入**: 支持连续输入多个目标
- [ ] **单目标处理**: 每次仅处理一个目标
- [ ] **文件导入**: 支持TXT、CSV、JSON格式
- [ ] **实时反馈**: 显示扫描进度和结果摘要
- [ ] **命令支持**: 支持queue、results、help等命令

### 用户体验验收
```bash
# 交互式扫描测试
python start.py scan --loop

# 输入测试
目标 > https://example.com
目标 > 192.168.1.1
目标 > file
文件路径 > scan.txt
目标 > queue
目标 > results
目标 > quit
```

### 文件导入验收
```bash
# 创建测试文件
echo "https://example.com" > scan.txt
echo "https://test.com" >> scan.txt

# CSV格式测试
echo "url,priority,description" > targets.csv
echo "https://example.com,5,主要目标" >> targets.csv

# JSON格式测试
echo '{"targets": ["https://example.com", "https://test.com"]}' > targets.json
```

## 交付物

### 核心功能
- [ ] 交互式扫描器主类
- [ ] 输入验证和目标解析
- [ ] 文件导入器（支持多格式）
- [ ] 扫描队列管理
- [ ] 实时结果展示

### 用户界面
- [ ] 友好的命令行交互界面
- [ ] 详细的帮助和错误提示
- [ ] 扫描进度实时显示
- [ ] 结果摘要和统计

### 配置和文档
- [ ] 循环扫描配置选项
- [ ] 文件格式示例和模板
- [ ] 用户使用指南
- [ ] 命令参考手册

---
**任务负责人**: Backend Engineer  
**审核人**: UX Designer  
**依赖任务**: Task 001, 002  
**预计工作量**: 2天  
**用户价值**: 显著提升扫描效率和用户体验