---
task_id: 005
title: "å¾ªç¯æ‰«ææ¨¡å¼ä¸æ–‡ä»¶å¯¼å…¥åŠŸèƒ½"
phase: 3
priority: high
estimated_effort: 2d
parallel: false
dependencies: ["001", "002"]
assignee: "backend-engineer"
tags: ["scanning", "user-experience", "interactive", "batch"]
---

# Task 005: å¾ªç¯æ‰«ææ¨¡å¼ä¸æ–‡ä»¶å¯¼å…¥åŠŸèƒ½ ğŸ”„

## æ¦‚è¿°
å®ç°äº¤äº’å¼å¾ªç¯æ‰«ææ¨¡å¼å’Œæ‰¹é‡æ–‡ä»¶å¯¼å…¥åŠŸèƒ½ï¼Œå…è®¸ç”¨æˆ·è¿ç»­è¾“å…¥ç›®æ ‡è¿›è¡Œæ‰«æï¼Œæ”¯æŒä»æ–‡ä»¶å¯¼å…¥ç›®æ ‡åˆ—è¡¨ï¼Œæ¯æ¬¡ä»…å¤„ç†ä¸€ä¸ªç›®æ ‡ï¼Œæä¾›ä¼˜ç§€çš„ç”¨æˆ·ä½“éªŒã€‚

## èƒŒæ™¯ä¸éœ€æ±‚
å½“å‰scanæ¨¡å¼åªèƒ½å•æ¬¡æ‰«æåé€€å‡ºï¼Œéœ€è¦å¢å¼ºä¸ºï¼š
1. **å¾ªç¯è¾“å…¥æ¨¡å¼**: ç”¨æˆ·å¯ä»¥è¿ç»­è¾“å…¥å¤šä¸ªç›®æ ‡
2. **å•ç›®æ ‡å¤„ç†**: æ¯æ¬¡ä»…å¤„ç†ä¸€ä¸ªç›®æ ‡ï¼Œç¡®ä¿èµ„æºå¯æ§
3. **æ–‡ä»¶å¯¼å…¥**: æ”¯æŒä»scan.txtç­‰æ–‡ä»¶æ‰¹é‡å¯¼å…¥ç›®æ ‡
4. **å®æ—¶åé¦ˆ**: æ˜¾ç¤ºæ‰«æè¿›åº¦å’Œç»“æœæ‘˜è¦

## æŠ€æœ¯æ¶æ„

### 1. å¾ªç¯æ‰«æå™¨æ¶æ„
```
InteractiveScanner (äº¤äº’å¼æ‰«æå™¨)
â”œâ”€â”€ InputManager (è¾“å…¥ç®¡ç†å™¨)
â”‚   â”œâ”€â”€ ConsoleInput (æ§åˆ¶å°è¾“å…¥)
â”‚   â”œâ”€â”€ FileInput (æ–‡ä»¶è¾“å…¥) 
â”‚   â””â”€â”€ ValidationInput (è¾“å…¥éªŒè¯)
â”œâ”€â”€ ScanQueue (æ‰«æé˜Ÿåˆ—)
â”‚   â”œâ”€â”€ TargetQueue (ç›®æ ‡é˜Ÿåˆ—)
â”‚   â”œâ”€â”€ PriorityManager (ä¼˜å…ˆçº§ç®¡ç†)
â”‚   â””â”€â”€ ProgressTracker (è¿›åº¦è·Ÿè¸ª)
â””â”€â”€ ResultPresenter (ç»“æœå±•ç¤ºå™¨)
    â”œâ”€â”€ RealTimeDisplay (å®æ—¶æ˜¾ç¤º)
    â”œâ”€â”€ SummaryReport (æ‘˜è¦æŠ¥å‘Š)
    â””â”€â”€ ExportManager (å¯¼å‡ºç®¡ç†)
```

### 2. æ”¯æŒçš„è¾“å…¥æ ¼å¼
- **æ§åˆ¶å°è¾“å…¥**: äº¤äº’å¼URLè¾“å…¥
- **TXTæ–‡ä»¶**: æ¯è¡Œä¸€ä¸ªURL
- **CSVæ–‡ä»¶**: å¸¦å…ƒæ•°æ®çš„ç›®æ ‡åˆ—è¡¨
- **JSONæ–‡ä»¶**: ç»“æ„åŒ–ç›®æ ‡é…ç½®

## å®æ–½æ­¥éª¤

### Step 1: è¾“å…¥ç®¡ç†å™¨å®ç° (0.5å¤©)

#### 1.1 è¾“å…¥éªŒè¯å™¨
```python
# vuln_scanner/core/scanner/input_validator.py
import re
import ipaddress
from urllib.parse import urlparse
from typing import List, Dict, Any, Optional
from dataclasses import dataclass

@dataclass
class TargetInfo:
    """ç›®æ ‡ä¿¡æ¯"""
    url: str
    target_type: str  # url, ip, domain, cidr
    scope: str = "single"  # single, subdomain, full_domain
    priority: int = 1  # 1-5, 5æœ€é«˜
    metadata: Dict[str, Any] = None
    
    def __post_init__(self):
        if self.metadata is None:
            self.metadata = {}

class InputValidator:
    """è¾“å…¥éªŒè¯å™¨ - éªŒè¯å’Œæ ‡å‡†åŒ–æ‰«æç›®æ ‡"""
    
    def __init__(self):
        self.url_pattern = re.compile(
            r'^https?://'  # httpæˆ–https
            r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+[A-Z]{2,6}\.?|'  # åŸŸå
            r'localhost|'  # localhost
            r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})'  # IPåœ°å€
            r'(?::\d+)?'  # ç«¯å£å·
            r'(?:/?|[/?]\S+)$', re.IGNORECASE)
    
    def validate_input(self, input_text: str) -> Optional[TargetInfo]:
        """éªŒè¯ç”¨æˆ·è¾“å…¥å¹¶è¿”å›æ ‡å‡†åŒ–çš„ç›®æ ‡ä¿¡æ¯"""
        input_text = input_text.strip()
        
        if not input_text:
            return None
        
        # æ£€æŸ¥ç‰¹æ®Šå‘½ä»¤
        if input_text.lower() in ['quit', 'exit', 'q']:
            return None
        
        # æ£€æŸ¥æ–‡ä»¶å¯¼å…¥å‘½ä»¤
        if input_text.lower() in ['file', 'import', 'f']:
            return TargetInfo(url="__FILE_IMPORT__", target_type="file_import")
        
        # éªŒè¯URLæ ¼å¼
        target_info = self._parse_target(input_text)
        if target_info:
            return target_info
        
        print(f"âŒ æ— æ•ˆçš„ç›®æ ‡æ ¼å¼: {input_text}")
        print("æ”¯æŒçš„æ ¼å¼:")
        print("  - URL: https://example.com")
        print("  - IP: 192.168.1.1")
        print("  - åŸŸå: example.com")
        print("  - CIDR: 192.168.1.0/24")
        print("  - æ–‡ä»¶å¯¼å…¥: file æˆ– import")
        print("  - é€€å‡º: quit æˆ– exit")
        return None
    
    def _parse_target(self, target: str) -> Optional[TargetInfo]:
        """è§£æç›®æ ‡å­—ç¬¦ä¸²"""
        # URLæ ¼å¼
        if target.startswith(('http://', 'https://')):
            if self.url_pattern.match(target):
                return TargetInfo(url=target, target_type="url")
        
        # IPåœ°å€
        try:
            ipaddress.ip_address(target)
            return TargetInfo(url=f"http://{target}", target_type="ip")
        except ValueError:
            pass
        
        # CIDRç½‘æ®µ
        try:
            ipaddress.ip_network(target, strict=False)
            return TargetInfo(url=target, target_type="cidr", scope="network")
        except ValueError:
            pass
        
        # åŸŸåï¼ˆæ·»åŠ http://å‰ç¼€ï¼‰
        if self._is_valid_domain(target):
            return TargetInfo(url=f"https://{target}", target_type="domain")
        
        return None
    
    def _is_valid_domain(self, domain: str) -> bool:
        """éªŒè¯åŸŸåæ ¼å¼"""
        domain_pattern = re.compile(
            r'^(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)*[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?$'
        )
        return bool(domain_pattern.match(domain))
```

#### 1.2 æ–‡ä»¶å¯¼å…¥å™¨
```python
# vuln_scanner/core/scanner/file_importer.py
import csv
import json
from pathlib import Path
from typing import List, Dict, Any, Iterator
from .input_validator import TargetInfo, InputValidator

class FileImporter:
    """æ–‡ä»¶å¯¼å…¥å™¨ - ä»æ–‡ä»¶æ‰¹é‡å¯¼å…¥æ‰«æç›®æ ‡"""
    
    def __init__(self):
        self.validator = InputValidator()
        self.supported_formats = ['.txt', '.csv', '.json']
        self.max_file_size = 10 * 1024 * 1024  # 10MB
        self.max_targets = 1000
    
    def import_from_file(self, file_path: str) -> List[TargetInfo]:
        """ä»æ–‡ä»¶å¯¼å…¥ç›®æ ‡åˆ—è¡¨"""
        file_path = Path(file_path)
        
        # éªŒè¯æ–‡ä»¶
        if not file_path.exists():
            raise FileNotFoundError(f"æ–‡ä»¶ä¸å­˜åœ¨: {file_path}")
        
        if file_path.stat().st_size > self.max_file_size:
            raise ValueError(f"æ–‡ä»¶è¿‡å¤§: {file_path.stat().st_size} bytes")
        
        if file_path.suffix.lower() not in self.supported_formats:
            raise ValueError(f"ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼: {file_path.suffix}")
        
        # æ ¹æ®æ–‡ä»¶ç±»å‹å¯¼å…¥
        if file_path.suffix.lower() == '.txt':
            return self._import_txt(file_path)
        elif file_path.suffix.lower() == '.csv':
            return self._import_csv(file_path)
        elif file_path.suffix.lower() == '.json':
            return self._import_json(file_path)
    
    def _import_txt(self, file_path: Path) -> List[TargetInfo]:
        """å¯¼å…¥TXTæ–‡ä»¶"""
        targets = []
        
        with open(file_path, 'r', encoding='utf-8') as f:
            for line_num, line in enumerate(f, 1):
                line = line.strip()
                if not line or line.startswith('#'):  # è·³è¿‡ç©ºè¡Œå’Œæ³¨é‡Š
                    continue
                
                target_info = self.validator.validate_input(line)
                if target_info:
                    targets.append(target_info)
                else:
                    print(f"âš ï¸ è·³è¿‡æ— æ•ˆç›®æ ‡ (è¡Œ {line_num}): {line}")
                
                if len(targets) >= self.max_targets:
                    print(f"âš ï¸ å·²è¾¾åˆ°æœ€å¤§ç›®æ ‡æ•°é‡é™åˆ¶: {self.max_targets}")
                    break
        
        return targets
    
    def _import_csv(self, file_path: Path) -> List[TargetInfo]:
        """å¯¼å…¥CSVæ–‡ä»¶"""
        targets = []
        
        with open(file_path, 'r', encoding='utf-8') as f:
            reader = csv.DictReader(f)
            
            for row_num, row in enumerate(reader, 2):  # ä»ç¬¬2è¡Œå¼€å§‹ï¼ˆç¬¬1è¡Œæ˜¯æ ‡é¢˜ï¼‰
                url = row.get('url', '').strip()
                if not url:
                    continue
                
                target_info = self.validator.validate_input(url)
                if target_info:
                    # æ·»åŠ CSVä¸­çš„å…ƒæ•°æ®
                    target_info.priority = int(row.get('priority', 1))
                    target_info.scope = row.get('scope', 'single')
                    target_info.metadata.update({
                        'description': row.get('description', ''),
                        'tags': row.get('tags', '').split(',') if row.get('tags') else []
                    })
                    targets.append(target_info)
                else:
                    print(f"âš ï¸ è·³è¿‡æ— æ•ˆç›®æ ‡ (è¡Œ {row_num}): {url}")
                
                if len(targets) >= self.max_targets:
                    break
        
        return targets
    
    def _import_json(self, file_path: Path) -> List[TargetInfo]:
        """å¯¼å…¥JSONæ–‡ä»¶"""
        with open(file_path, 'r', encoding='utf-8') as f:
            data = json.load(f)
        
        targets = []
        target_list = data.get('targets', []) if isinstance(data, dict) else data
        
        for item in target_list:
            if isinstance(item, str):
                target_info = self.validator.validate_input(item)
            elif isinstance(item, dict):
                url = item.get('url', '')
                target_info = self.validator.validate_input(url)
                if target_info:
                    target_info.priority = item.get('priority', 1)
                    target_info.scope = item.get('scope', 'single')
                    target_info.metadata.update(item.get('metadata', {}))
            else:
                continue
            
            if target_info:
                targets.append(target_info)
            
            if len(targets) >= self.max_targets:
                break
        
        return targets
```

### Step 2: äº¤äº’å¼æ‰«æå™¨æ ¸å¿ƒ (1å¤©)

#### 2.1 æ‰«æé˜Ÿåˆ—ç®¡ç†
```python
# vuln_scanner/core/scanner/interactive_scanner.py
import asyncio
from typing import List, Optional, Dict, Any
from pathlib import Path
from .input_validator import InputValidator, TargetInfo
from .file_importer import FileImporter
from ..config.models import VulnMinerConfig

class InteractiveScanner:
    """äº¤äº’å¼æ‰«æå™¨ - æ”¯æŒå¾ªç¯è¾“å…¥å’Œå•ç›®æ ‡å¤„ç†"""
    
    def __init__(self, config: VulnMinerConfig):
        self.config = config
        self.validator = InputValidator()
        self.file_importer = FileImporter()
        self.scan_queue: List[TargetInfo] = []
        self.scan_results: List[Dict[str, Any]] = []
        self.running = False
        
    async def run_interactive_mode(self):
        """è¿è¡Œäº¤äº’å¼æ‰«ææ¨¡å¼"""
        self.running = True
        
        print("ğŸ” VulnMiner å¾ªç¯æ‰«ææ¨¡å¼")
        print("=" * 50)
        print("å‘½ä»¤è¯´æ˜:")
        print("  â€¢ è¾“å…¥ç›®æ ‡URLè¿›è¡Œæ‰«æ")
        print("  â€¢ 'file' æˆ– 'import' - ä»æ–‡ä»¶å¯¼å…¥ç›®æ ‡")
        print("  â€¢ 'queue' - æ˜¾ç¤ºå½“å‰é˜Ÿåˆ—")
        print("  â€¢ 'results' - æ˜¾ç¤ºæ‰«æç»“æœ")
        print("  â€¢ 'quit' æˆ– 'exit' - é€€å‡ºç¨‹åº")
        print("=" * 50)
        
        while self.running:
            try:
                # æ˜¾ç¤ºé˜Ÿåˆ—çŠ¶æ€
                if self.scan_queue:
                    print(f"\nğŸ“‹ é˜Ÿåˆ—ä¸­æœ‰ {len(self.scan_queue)} ä¸ªç›®æ ‡å¾…æ‰«æ")
                
                # è·å–ç”¨æˆ·è¾“å…¥
                user_input = input("\nğŸ¯ ç›®æ ‡ > ").strip()
                
                if not user_input:
                    continue
                
                # å¤„ç†ç‰¹æ®Šå‘½ä»¤
                if await self._handle_special_commands(user_input):
                    continue
                
                # éªŒè¯å¹¶æ·»åŠ ç›®æ ‡
                target_info = self.validator.validate_input(user_input)
                if target_info:
                    if target_info.target_type == "file_import":
                        await self._handle_file_import()
                    else:
                        await self._add_target_to_queue(target_info)
                
            except KeyboardInterrupt:
                print("\n\nğŸ›‘ æ£€æµ‹åˆ° Ctrl+Cï¼Œæ­£åœ¨é€€å‡º...")
                break
            except EOFError:
                print("\nğŸ‘‹ è¾“å…¥ç»“æŸï¼Œé€€å‡ºç¨‹åº")
                break
            except Exception as e:
                print(f"âŒ å¤„ç†è¾“å…¥æ—¶å‘ç”Ÿé”™è¯¯: {e}")
        
        print("\nğŸ‘‹ æ„Ÿè°¢ä½¿ç”¨ VulnMiner!")
    
    async def _handle_special_commands(self, command: str) -> bool:
        """å¤„ç†ç‰¹æ®Šå‘½ä»¤"""
        command = command.lower()
        
        if command in ['quit', 'exit', 'q']:
            self.running = False
            return True
        
        elif command == 'queue':
            self._show_queue_status()
            return True
        
        elif command == 'results':
            self._show_scan_results()
            return True
        
        elif command == 'clear':
            self.scan_queue.clear()
            print("âœ… é˜Ÿåˆ—å·²æ¸…ç©º")
            return True
        
        elif command == 'help':
            self._show_help()
            return True
        
        return False
    
    async def _add_target_to_queue(self, target_info: TargetInfo):
        """æ·»åŠ ç›®æ ‡åˆ°é˜Ÿåˆ—å¹¶ç«‹å³å¼€å§‹æ‰«æ"""
        print(f"ğŸ“ æ·»åŠ ç›®æ ‡: {target_info.url}")
        
        # ç«‹å³æ‰«æè¯¥ç›®æ ‡ï¼ˆå•ç›®æ ‡å¤„ç†ï¼‰
        await self._scan_single_target(target_info)
    
    async def _scan_single_target(self, target_info: TargetInfo):
        """æ‰«æå•ä¸ªç›®æ ‡"""
        print(f"\nğŸš€ å¼€å§‹æ‰«æ: {target_info.url}")
        print("=" * 60)
        
        try:
            # è¿™é‡Œè°ƒç”¨å®é™…çš„æ‰«æå¼•æ“
            from ..scanning.scan_engine import ScanEngine
            
            scan_engine = ScanEngine(self.config)
            
            # æ ¹æ®ç›®æ ‡ç±»å‹é€‰æ‹©æ‰«æç®¡é“
            if target_info.target_type in ['url', 'domain']:
                result = await scan_engine.run_web_scan(target_info.url)
            elif target_info.target_type == 'ip':
                result = await scan_engine.run_network_scan(target_info.url)
            elif target_info.target_type == 'cidr':
                result = await scan_engine.run_network_range_scan(target_info.url)
            else:
                result = await scan_engine.run_quick_scan(target_info.url)
            
            # ä¿å­˜æ‰«æç»“æœ
            scan_result = {
                'target': target_info.url,
                'type': target_info.target_type,
                'start_time': result.get('start_time'),
                'end_time': result.get('end_time'),
                'duration': result.get('duration'),
                'findings': result.get('findings', []),
                'status': result.get('status', 'completed'),
                'metadata': target_info.metadata
            }
            
            self.scan_results.append(scan_result)
            
            # æ˜¾ç¤ºæ‰«ææ‘˜è¦
            self._show_scan_summary(scan_result)
            
        except Exception as e:
            print(f"âŒ æ‰«æå¤±è´¥: {e}")
            # è®°å½•å¤±è´¥ç»“æœ
            self.scan_results.append({
                'target': target_info.url,
                'status': 'failed',
                'error': str(e),
                'metadata': target_info.metadata
            })
    
    def _show_scan_summary(self, result: Dict[str, Any]):
        """æ˜¾ç¤ºæ‰«æç»“æœæ‘˜è¦"""
        print("\nğŸ“Š æ‰«æç»“æœæ‘˜è¦:")
        print("-" * 30)
        print(f"ç›®æ ‡: {result['target']}")
        print(f"çŠ¶æ€: {result['status']}")
        print(f"è€—æ—¶: {result.get('duration', 0):.1f}ç§’")
        
        findings = result.get('findings', [])
        if findings:
            severity_counts = {}
            for finding in findings:
                severity = finding.get('severity', 'unknown')
                severity_counts[severity] = severity_counts.get(severity, 0) + 1
            
            print(f"å‘ç°é—®é¢˜: {len(findings)}ä¸ª")
            for severity, count in severity_counts.items():
                print(f"  - {severity}: {count}ä¸ª")
        else:
            print("âœ… æœªå‘ç°å®‰å…¨é—®é¢˜")
        
        print("-" * 30)
    
    async def _handle_file_import(self):
        """å¤„ç†æ–‡ä»¶å¯¼å…¥"""
        print("\nğŸ“ æ–‡ä»¶å¯¼å…¥æ¨¡å¼")
        print("æ”¯æŒæ ¼å¼: .txt, .csv, .json")
        print("ç¤ºä¾‹æ–‡ä»¶è·¯å¾„: scan.txt, targets.csv, config.json")
        
        file_path = input("ğŸ“‚ æ–‡ä»¶è·¯å¾„ > ").strip()
        
        if not file_path:
            print("âŒ æœªæŒ‡å®šæ–‡ä»¶è·¯å¾„")
            return
        
        try:
            targets = self.file_importer.import_from_file(file_path)
            
            if not targets:
                print("âŒ æ–‡ä»¶ä¸­æ²¡æœ‰æœ‰æ•ˆçš„ç›®æ ‡")
                return
            
            print(f"âœ… æˆåŠŸå¯¼å…¥ {len(targets)} ä¸ªç›®æ ‡")
            
            # è¯¢é—®æ˜¯å¦ç«‹å³å¼€å§‹æ‰«æ
            confirm = input(f"æ˜¯å¦ç«‹å³å¼€å§‹æ‰«æè¿™ {len(targets)} ä¸ªç›®æ ‡? (y/N): ").strip().lower()
            
            if confirm in ['y', 'yes']:
                for i, target in enumerate(targets, 1):
                    print(f"\n[{i}/{len(targets)}] æ‰«æè¿›åº¦")
                    await self._scan_single_target(target)
                    
                    # æ‰«æé—´éš”ï¼ˆé¿å…è¿‡äºé¢‘ç¹ï¼‰
                    if i < len(targets):
                        await asyncio.sleep(2)
            else:
                self.scan_queue.extend(targets)
                print(f"âœ… å·²å°† {len(targets)} ä¸ªç›®æ ‡æ·»åŠ åˆ°é˜Ÿåˆ—")
                
        except Exception as e:
            print(f"âŒ æ–‡ä»¶å¯¼å…¥å¤±è´¥: {e}")
    
    def _show_queue_status(self):
        """æ˜¾ç¤ºé˜Ÿåˆ—çŠ¶æ€"""
        if not self.scan_queue:
            print("ğŸ“‹ æ‰«æé˜Ÿåˆ—ä¸ºç©º")
            return
        
        print(f"\nğŸ“‹ æ‰«æé˜Ÿåˆ— ({len(self.scan_queue)} ä¸ªç›®æ ‡):")
        print("-" * 50)
        for i, target in enumerate(self.scan_queue, 1):
            print(f"{i:2d}. {target.url} ({target.target_type})")
        print("-" * 50)
    
    def _show_scan_results(self):
        """æ˜¾ç¤ºæ‰«æç»“æœ"""
        if not self.scan_results:
            print("ğŸ“Š æš‚æ— æ‰«æç»“æœ")
            return
        
        print(f"\nğŸ“Š æ‰«æç»“æœ ({len(self.scan_results)} ä¸ª):")
        print("-" * 60)
        
        for i, result in enumerate(self.scan_results, 1):
            status_icon = "âœ…" if result['status'] == 'completed' else "âŒ"
            findings_count = len(result.get('findings', []))
            
            print(f"{i:2d}. {status_icon} {result['target']}")
            if result['status'] == 'completed':
                print(f"    å‘ç°: {findings_count}ä¸ªé—®é¢˜")
            else:
                print(f"    é”™è¯¯: {result.get('error', 'unknown')}")
        
        print("-" * 60)
    
    def _show_help(self):
        """æ˜¾ç¤ºå¸®åŠ©ä¿¡æ¯"""
        help_text = """
ğŸ” VulnMiner äº¤äº’å¼æ‰«æå¸®åŠ©

æ”¯æŒçš„ç›®æ ‡æ ¼å¼:
  â€¢ URL: https://example.com, http://test.com:8080
  â€¢ åŸŸå: example.com (è‡ªåŠ¨æ·»åŠ https://)
  â€¢ IPåœ°å€: 192.168.1.1 (è‡ªåŠ¨æ·»åŠ http://)
  â€¢ ç½‘æ®µ: 192.168.1.0/24

æ”¯æŒçš„å‘½ä»¤:
  â€¢ file, import - ä»æ–‡ä»¶å¯¼å…¥ç›®æ ‡
  â€¢ queue - æ˜¾ç¤ºå½“å‰æ‰«æé˜Ÿåˆ—
  â€¢ results - æ˜¾ç¤ºæ‰«æç»“æœæ‘˜è¦
  â€¢ clear - æ¸…ç©ºæ‰«æé˜Ÿåˆ—
  â€¢ help - æ˜¾ç¤ºæ­¤å¸®åŠ©ä¿¡æ¯
  â€¢ quit, exit - é€€å‡ºç¨‹åº

æ–‡ä»¶å¯¼å…¥æ ¼å¼:
  â€¢ TXT: æ¯è¡Œä¸€ä¸ªURL
  â€¢ CSV: url,priority,scope,description
  â€¢ JSON: {"targets": ["url1", "url2"]}

æ‰«æç‰¹ç‚¹:
  â€¢ å•ç›®æ ‡å¤„ç† - æ¯æ¬¡ä»…æ‰«æä¸€ä¸ªç›®æ ‡
  â€¢ å®æ—¶åé¦ˆ - æ˜¾ç¤ºæ‰«æè¿›åº¦å’Œç»“æœ
  â€¢ æ™ºèƒ½è¯†åˆ« - è‡ªåŠ¨è¯†åˆ«ç›®æ ‡ç±»å‹
        """
        print(help_text)
```

## éªŒæ”¶æ ‡å‡†

### åŠŸèƒ½æ€§éªŒæ”¶
- [ ] **å¾ªç¯è¾“å…¥**: æ”¯æŒè¿ç»­è¾“å…¥å¤šä¸ªç›®æ ‡
- [ ] **å•ç›®æ ‡å¤„ç†**: æ¯æ¬¡ä»…å¤„ç†ä¸€ä¸ªç›®æ ‡
- [ ] **æ–‡ä»¶å¯¼å…¥**: æ”¯æŒTXTã€CSVã€JSONæ ¼å¼
- [ ] **å®æ—¶åé¦ˆ**: æ˜¾ç¤ºæ‰«æè¿›åº¦å’Œç»“æœæ‘˜è¦
- [ ] **å‘½ä»¤æ”¯æŒ**: æ”¯æŒqueueã€resultsã€helpç­‰å‘½ä»¤

### ç”¨æˆ·ä½“éªŒéªŒæ”¶
```bash
# äº¤äº’å¼æ‰«ææµ‹è¯•
python start.py scan --loop

# è¾“å…¥æµ‹è¯•
ç›®æ ‡ > https://example.com
ç›®æ ‡ > 192.168.1.1
ç›®æ ‡ > file
æ–‡ä»¶è·¯å¾„ > scan.txt
ç›®æ ‡ > queue
ç›®æ ‡ > results
ç›®æ ‡ > quit
```

### æ–‡ä»¶å¯¼å…¥éªŒæ”¶
```bash
# åˆ›å»ºæµ‹è¯•æ–‡ä»¶
echo "https://example.com" > scan.txt
echo "https://test.com" >> scan.txt

# CSVæ ¼å¼æµ‹è¯•
echo "url,priority,description" > targets.csv
echo "https://example.com,5,ä¸»è¦ç›®æ ‡" >> targets.csv

# JSONæ ¼å¼æµ‹è¯•
echo '{"targets": ["https://example.com", "https://test.com"]}' > targets.json
```

## äº¤ä»˜ç‰©

### æ ¸å¿ƒåŠŸèƒ½
- [ ] äº¤äº’å¼æ‰«æå™¨ä¸»ç±»
- [ ] è¾“å…¥éªŒè¯å’Œç›®æ ‡è§£æ
- [ ] æ–‡ä»¶å¯¼å…¥å™¨ï¼ˆæ”¯æŒå¤šæ ¼å¼ï¼‰
- [ ] æ‰«æé˜Ÿåˆ—ç®¡ç†
- [ ] å®æ—¶ç»“æœå±•ç¤º

### ç”¨æˆ·ç•Œé¢
- [ ] å‹å¥½çš„å‘½ä»¤è¡Œäº¤äº’ç•Œé¢
- [ ] è¯¦ç»†çš„å¸®åŠ©å’Œé”™è¯¯æç¤º
- [ ] æ‰«æè¿›åº¦å®æ—¶æ˜¾ç¤º
- [ ] ç»“æœæ‘˜è¦å’Œç»Ÿè®¡

### é…ç½®å’Œæ–‡æ¡£
- [ ] å¾ªç¯æ‰«æé…ç½®é€‰é¡¹
- [ ] æ–‡ä»¶æ ¼å¼ç¤ºä¾‹å’Œæ¨¡æ¿
- [ ] ç”¨æˆ·ä½¿ç”¨æŒ‡å—
- [ ] å‘½ä»¤å‚è€ƒæ‰‹å†Œ

---
**ä»»åŠ¡è´Ÿè´£äºº**: Backend Engineer  
**å®¡æ ¸äºº**: UX Designer  
**ä¾èµ–ä»»åŠ¡**: Task 001, 002  
**é¢„è®¡å·¥ä½œé‡**: 2å¤©  
**ç”¨æˆ·ä»·å€¼**: æ˜¾è‘—æå‡æ‰«ææ•ˆç‡å’Œç”¨æˆ·ä½“éªŒ