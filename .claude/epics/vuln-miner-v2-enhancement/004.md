---
task_id: 004
title: "AI LLMsé€‚é…å™¨å®ç°"
phase: 2
priority: high
estimated_effort: 3d
parallel: false
dependencies: ["001", "002"]
assignee: "ai-engineer"
tags: ["ai", "llm", "integration", "openai", "claude"]
---

# Task 004: AI LLMsé€‚é…å™¨å®ç° ğŸ¤–

## æ¦‚è¿°
å®ç°å¤šAIæä¾›å•†é€‚é…å™¨æ¶æ„ï¼Œæ”¯æŒOpenAIã€Claudeã€Ollamaç­‰ä¸»æµLLMsï¼Œæä¾›ç»Ÿä¸€çš„AIåˆ†ææ¥å£ï¼Œä¸ºVulnMineræ·»åŠ æ™ºèƒ½æ¼æ´åˆ†æå’ŒæŠ¥å‘Šç”Ÿæˆèƒ½åŠ›ã€‚

## èƒŒæ™¯ä¸ç›®æ ‡
å°†AIèƒ½åŠ›é›†æˆåˆ°VulnMinerä¸­ï¼Œå®ç°ï¼š
1. **å¤šæä¾›å•†æ”¯æŒ**: OpenAI GPT-4ã€Claude 3ã€Ollamaæœ¬åœ°æ¨¡å‹
2. **æ™ºèƒ½åˆ†æ**: æ¼æ´éªŒè¯ã€é£é™©è¯„ä¼°ã€è¯¯æŠ¥è¿‡æ»¤
3. **æ•…éšœè½¬ç§»**: è‡ªåŠ¨åˆ‡æ¢å¤‡ç”¨æä¾›å•†
4. **æˆæœ¬æ§åˆ¶**: Tokenä½¿ç”¨ä¼˜åŒ–å’Œè´¹ç”¨ç›‘æ§

## æŠ€æœ¯æ¶æ„

### 1. é€‚é…å™¨æ¨¡å¼è®¾è®¡
```
AIManager (ç®¡ç†å™¨)
â”œâ”€â”€ OpenAIProvider (OpenAIé€‚é…å™¨)
â”œâ”€â”€ ClaudeProvider (Claudeé€‚é…å™¨)  
â”œâ”€â”€ OllamaProvider (Ollamaé€‚é…å™¨)
â””â”€â”€ MockProvider (æµ‹è¯•é€‚é…å™¨)

æ¯ä¸ªé€‚é…å™¨å®ç°ç»Ÿä¸€æ¥å£ï¼š
- analyze_vulnerability() - æ¼æ´åˆ†æ
- generate_report() - æŠ¥å‘Šç”Ÿæˆ
- classify_risk() - é£é™©åˆ†ç±»
- filter_false_positives() - è¯¯æŠ¥è¿‡æ»¤
```

### 2. AIåŠŸèƒ½æ¨¡å—
- **æ¼æ´åˆ†æ**: æ·±åº¦åˆ†ææ‰«æç»“æœï¼Œæä¾›ä¸“ä¸šè§£é‡Š
- **é£é™©è¯„ä¼°**: åŸºäºä¸Šä¸‹æ–‡çš„CVSSè¯„åˆ†å’Œé£é™©ç­‰çº§
- **æŠ¥å‘Šä¼˜åŒ–**: ç”Ÿæˆä¸“ä¸šçš„æ¼æ´æŠ¥å‘Šå’Œä¿®å¤å»ºè®®
- **è¯¯æŠ¥è¿‡æ»¤**: æ™ºèƒ½è¯†åˆ«å’Œè¿‡æ»¤è¯¯æŠ¥ç»“æœ

## å®æ–½æ­¥éª¤

### Step 1: æ ¸å¿ƒæ¥å£å’ŒåŸºç±» (0.5å¤©)

#### 1.1 AIæä¾›å•†åŸºç±»
```python
# vuln_scanner/core/ai/base.py
from abc import ABC, abstractmethod
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
from enum import Enum

class RiskLevel(Enum):
    """é£é™©ç­‰çº§æšä¸¾"""
    CRITICAL = "critical"
    HIGH = "high" 
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"

@dataclass
class VulnerabilityAnalysis:
    """æ¼æ´åˆ†æç»“æœ"""
    severity: RiskLevel
    confidence: float  # 0.0-1.0
    cvss_score: Optional[float]
    description: str
    impact: str
    remediation: str
    false_positive_probability: float
    references: List[str]

@dataclass
class AIProviderConfig:
    """AIæä¾›å•†é…ç½®"""
    name: str
    api_key: Optional[str]
    base_url: str
    model: str
    timeout: int = 30
    max_tokens: int = 4000
    temperature: float = 0.1

class AIProvider(ABC):
    """AIæä¾›å•†åŸºç±»"""
    
    def __init__(self, config: AIProviderConfig):
        self.config = config
        self.name = config.name
        
    @abstractmethod
    async def analyze_vulnerability(self, finding: Dict[str, Any]) -> VulnerabilityAnalysis:
        """åˆ†æå•ä¸ªæ¼æ´å‘ç°"""
        pass
    
    @abstractmethod 
    async def generate_report_summary(self, findings: List[Dict[str, Any]]) -> str:
        """ç”ŸæˆæŠ¥å‘Šæ‘˜è¦"""
        pass
    
    @abstractmethod
    async def classify_risk(self, vulnerability: Dict[str, Any]) -> RiskLevel:
        """é£é™©åˆ†ç±»"""
        pass
    
    @abstractmethod
    async def filter_false_positives(self, findings: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """è¿‡æ»¤è¯¯æŠ¥"""
        pass
    
    @abstractmethod
    async def health_check(self) -> bool:
        """å¥åº·æ£€æŸ¥"""
        pass
```

#### 1.2 AIç®¡ç†å™¨æ ¸å¿ƒ
```python
# vuln_scanner/core/ai/manager.py
import logging
from typing import Dict, List, Optional, Type
from .base import AIProvider, VulnerabilityAnalysis, RiskLevel
from .providers import OpenAIProvider, ClaudeProvider, OllamaProvider
from ..config.models import AIConfig

class AIManager:
    """AIæœåŠ¡ç®¡ç†å™¨ - ç»Ÿä¸€ç®¡ç†å¤šä¸ªAIæä¾›å•†"""
    
    def __init__(self, config: AIConfig):
        self.config = config
        self.logger = logging.getLogger(__name__)
        self.providers: Dict[str, AIProvider] = {}
        self.fallback_order = config.fallback_order
        
        # åˆå§‹åŒ–æä¾›å•†
        self._initialize_providers()
    
    def _initialize_providers(self):
        """åˆå§‹åŒ–AIæä¾›å•†"""
        provider_classes = {
            "openai": OpenAIProvider,
            "claude": ClaudeProvider, 
            "ollama": OllamaProvider
        }
        
        for provider_name, provider_config in self.config.providers.items():
            if provider_name in provider_classes:
                try:
                    provider_class = provider_classes[provider_name]
                    provider = provider_class(provider_config)
                    self.providers[provider_name] = provider
                    self.logger.info(f"âœ… AIæä¾›å•† {provider_name} åˆå§‹åŒ–æˆåŠŸ")
                except Exception as e:
                    self.logger.error(f"âŒ AIæä¾›å•† {provider_name} åˆå§‹åŒ–å¤±è´¥: {e}")
    
    async def analyze_vulnerability(self, finding: Dict[str, Any]) -> Optional[VulnerabilityAnalysis]:
        """ä½¿ç”¨AIåˆ†ææ¼æ´ï¼ˆå¸¦æ•…éšœè½¬ç§»ï¼‰"""
        for provider_name in self.fallback_order:
            if provider_name not in self.providers:
                continue
                
            try:
                provider = self.providers[provider_name]
                result = await provider.analyze_vulnerability(finding)
                self.logger.info(f"âœ… ä½¿ç”¨ {provider_name} å®Œæˆæ¼æ´åˆ†æ")
                return result
            except Exception as e:
                self.logger.warning(f"âš ï¸ AIæä¾›å•† {provider_name} åˆ†æå¤±è´¥: {e}")
                continue
        
        # æ‰€æœ‰AIæä¾›å•†éƒ½å¤±è´¥ï¼Œä½¿ç”¨ä¼ ç»Ÿè§„åˆ™åˆ†æ
        self.logger.warning("æ‰€æœ‰AIæä¾›å•†å¤±è´¥ï¼Œä½¿ç”¨ä¼ ç»Ÿè§„åˆ™åˆ†æ")
        return self._fallback_analysis(finding)
    
    def _fallback_analysis(self, finding: Dict[str, Any]) -> VulnerabilityAnalysis:
        """ä¼ ç»Ÿè§„åˆ™åˆ†æï¼ˆAIæ•…éšœæ—¶çš„å¤‡é€‰æ–¹æ¡ˆï¼‰"""
        # åŸºäºè§„åˆ™çš„ç®€å•åˆ†æ
        severity = self._rule_based_severity(finding)
        
        return VulnerabilityAnalysis(
            severity=severity,
            confidence=0.7,  # è§„åˆ™åˆ†æç½®ä¿¡åº¦è¾ƒä½
            cvss_score=None,
            description=f"åŸºäºè§„åˆ™åˆ†æçš„ {finding.get('type', 'unknown')} æ¼æ´",
            impact="éœ€è¦äººå·¥ç¡®è®¤å½±å“ç¨‹åº¦",
            remediation="è¯·å‚è€ƒæ ‡å‡†å®‰å…¨æŒ‡å—è¿›è¡Œä¿®å¤",
            false_positive_probability=0.3,
            references=[]
        )
```

### Step 2: OpenAIé€‚é…å™¨å®ç° (1å¤©)

#### 2.1 OpenAIæä¾›å•†
```python
# vuln_scanner/core/ai/providers/openai_provider.py
import asyncio
import openai
from typing import Dict, List, Any
from ..base import AIProvider, VulnerabilityAnalysis, RiskLevel, AIProviderConfig

class OpenAIProvider(AIProvider):
    """OpenAI GPTæä¾›å•†"""
    
    def __init__(self, config: AIProviderConfig):
        super().__init__(config)
        openai.api_key = config.api_key
        if config.base_url:
            openai.api_base = config.base_url
    
    async def analyze_vulnerability(self, finding: Dict[str, Any]) -> VulnerabilityAnalysis:
        """ä½¿ç”¨GPTåˆ†ææ¼æ´"""
        prompt = self._create_vulnerability_prompt(finding)
        
        try:
            response = await openai.ChatCompletion.acreate(
                model=self.config.model,
                messages=[
                    {"role": "system", "content": self._get_system_prompt()},
                    {"role": "user", "content": prompt}
                ],
                max_tokens=self.config.max_tokens,
                temperature=self.config.temperature,
                timeout=self.config.timeout
            )
            
            analysis_text = response.choices[0].message.content
            return self._parse_analysis_response(analysis_text)
            
        except Exception as e:
            self.logger.error(f"OpenAI APIè°ƒç”¨å¤±è´¥: {e}")
            raise
    
    def _get_system_prompt(self) -> str:
        """è·å–ç³»ç»Ÿæç¤ºè¯"""
        return """ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„ç½‘ç»œå®‰å…¨ä¸“å®¶ï¼Œè´Ÿè´£åˆ†ææ¼æ´æ‰«æç»“æœã€‚

è¯·æŒ‰ç…§ä»¥ä¸‹æ ¼å¼åˆ†ææ¼æ´ï¼š
1. é£é™©ç­‰çº§ (critical/high/medium/low/info)
2. ç½®ä¿¡åº¦ (0.0-1.0)
3. CVSSè¯„åˆ† (0.0-10.0)
4. è¯¦ç»†æè¿°
5. å½±å“åˆ†æ
6. ä¿®å¤å»ºè®®
7. è¯¯æŠ¥æ¦‚ç‡ (0.0-1.0)
8. ç›¸å…³å‚è€ƒ

ä½¿ç”¨JSONæ ¼å¼å›å¤ï¼Œç¡®ä¿ä¸“ä¸šæ€§å’Œå‡†ç¡®æ€§ã€‚è€ƒè™‘ä¸­æ–‡ç”¨æˆ·çš„ç†è§£ä¹ æƒ¯ã€‚"""
    
    def _create_vulnerability_prompt(self, finding: Dict[str, Any]) -> str:
        """åˆ›å»ºæ¼æ´åˆ†ææç¤ºè¯"""
        return f"""
è¯·åˆ†æä»¥ä¸‹æ¼æ´æ‰«æç»“æœï¼š

æ‰«æå·¥å…·: {finding.get('tool', 'unknown')}
ç›®æ ‡: {finding.get('target', 'unknown')}
æ¼æ´ç±»å‹: {finding.get('type', 'unknown')}
å‘ç°è¯¦æƒ…: {finding.get('details', 'N/A')}
åŸå§‹è¾“å‡º: {finding.get('raw_output', 'N/A')}

è¯·æä¾›ä¸“ä¸šçš„æ¼æ´åˆ†æï¼ŒåŒ…æ‹¬é£é™©è¯„ä¼°å’Œä¿®å¤å»ºè®®ã€‚
"""
    
    def _parse_analysis_response(self, response_text: str) -> VulnerabilityAnalysis:
        """è§£æAIå“åº”ä¸ºç»“æ„åŒ–æ•°æ®"""
        try:
            import json
            data = json.loads(response_text)
            
            return VulnerabilityAnalysis(
                severity=RiskLevel(data.get('severity', 'medium')),
                confidence=float(data.get('confidence', 0.8)),
                cvss_score=data.get('cvss_score'),
                description=data.get('description', ''),
                impact=data.get('impact', ''),
                remediation=data.get('remediation', ''),
                false_positive_probability=float(data.get('false_positive_probability', 0.1)),
                references=data.get('references', [])
            )
        except (json.JSONDecodeError, KeyError, ValueError) as e:
            # å¦‚æœè§£æå¤±è´¥ï¼Œè¿”å›åŸºç¡€åˆ†æ
            return VulnerabilityAnalysis(
                severity=RiskLevel.MEDIUM,
                confidence=0.6,
                cvss_score=None,
                description=response_text[:500],  # æˆªå–å‰500å­—ç¬¦
                impact="éœ€è¦äººå·¥éªŒè¯",
                remediation="è¯·å‚è€ƒå®‰å…¨æœ€ä½³å®è·µ",
                false_positive_probability=0.2,
                references=[]
            )
    
    async def generate_report_summary(self, findings: List[Dict[str, Any]]) -> str:
        """ç”ŸæˆæŠ¥å‘Šæ‘˜è¦"""
        summary_prompt = f"""
åŸºäºä»¥ä¸‹æ‰«æç»“æœç”Ÿæˆä¸“ä¸šçš„å®‰å…¨è¯„ä¼°æŠ¥å‘Šæ‘˜è¦ï¼š

æ‰«æå‘ç°æ•°é‡: {len(findings)}
å‘ç°ç±»å‹: {list(set(f.get('type', 'unknown') for f in findings))}

è¯·ç”Ÿæˆä¸€ä¸ªç®€æ´è€Œä¸“ä¸šçš„æ‘˜è¦ï¼ŒåŒ…æ‹¬ï¼š
1. æ€»ä½“å®‰å…¨çŠ¶å†µ
2. ä¸»è¦é£é™©ç‚¹
3. ä¼˜å…ˆä¿®å¤å»ºè®®
4. æ•´ä½“é£é™©è¯„çº§

ç”¨ä¸­æ–‡å›å¤ï¼Œä¿æŒä¸“ä¸šæ€§ã€‚
"""
        
        try:
            response = await openai.ChatCompletion.acreate(
                model=self.config.model,
                messages=[
                    {"role": "system", "content": "ä½ æ˜¯ä¸€ä¸ªç½‘ç»œå®‰å…¨ä¸“å®¶ï¼Œè´Ÿè´£æ’°å†™ä¸“ä¸šçš„å®‰å…¨è¯„ä¼°æŠ¥å‘Šã€‚"},
                    {"role": "user", "content": summary_prompt}
                ],
                max_tokens=1000,
                temperature=0.1
            )
            
            return response.choices[0].message.content
        except Exception as e:
            return f"æŠ¥å‘Šæ‘˜è¦ç”Ÿæˆå¤±è´¥: {e}"
    
    async def health_check(self) -> bool:
        """å¥åº·æ£€æŸ¥"""
        try:
            await openai.ChatCompletion.acreate(
                model=self.config.model,
                messages=[{"role": "user", "content": "ping"}],
                max_tokens=10,
                timeout=5
            )
            return True
        except Exception:
            return False
```

### Step 3: Claudeé€‚é…å™¨å®ç° (1å¤©)

#### 3.1 Claudeæä¾›å•†
```python
# vuln_scanner/core/ai/providers/claude_provider.py
import asyncio
import anthropic
from typing import Dict, List, Any
from ..base import AIProvider, VulnerabilityAnalysis, RiskLevel, AIProviderConfig

class ClaudeProvider(AIProvider):
    """Claude AIæä¾›å•†"""
    
    def __init__(self, config: AIProviderConfig):
        super().__init__(config)
        self.client = anthropic.AsyncAnthropic(
            api_key=config.api_key,
            base_url=config.base_url if config.base_url else None
        )
    
    async def analyze_vulnerability(self, finding: Dict[str, Any]) -> VulnerabilityAnalysis:
        """ä½¿ç”¨Claudeåˆ†ææ¼æ´"""
        prompt = self._create_vulnerability_prompt(finding)
        
        try:
            message = await self.client.messages.create(
                model=self.config.model,
                max_tokens=self.config.max_tokens,
                temperature=self.config.temperature,
                system=self._get_system_prompt(),
                messages=[
                    {"role": "user", "content": prompt}
                ]
            )
            
            analysis_text = message.content[0].text
            return self._parse_analysis_response(analysis_text)
            
        except Exception as e:
            self.logger.error(f"Claude APIè°ƒç”¨å¤±è´¥: {e}")
            raise
    
    def _get_system_prompt(self) -> str:
        """è·å–ç³»ç»Ÿæç¤ºè¯"""
        return """ä½ æ˜¯ä¸€ä½ç»éªŒä¸°å¯Œçš„ç½‘ç»œå®‰å…¨ä¸“å®¶ï¼Œä¸“é—¨è´Ÿè´£åˆ†ææ¼æ´æ‰«æç»“æœã€‚

åˆ†æä»»åŠ¡è¦æ±‚ï¼š
1. å‡†ç¡®è¯„ä¼°æ¼æ´çš„çœŸå®é£é™©ç­‰çº§
2. è€ƒè™‘å®é™…ç¯å¢ƒä¸­çš„å¯åˆ©ç”¨æ€§
3. æä¾›å…·ä½“å¯è¡Œçš„ä¿®å¤æ–¹æ¡ˆ
4. è¯†åˆ«å¯èƒ½çš„è¯¯æŠ¥æƒ…å†µ

è¯·ä½¿ç”¨JSONæ ¼å¼å›å¤ï¼ŒåŒ…å«ä»¥ä¸‹å­—æ®µï¼š
- severity: critical/high/medium/low/info
- confidence: 0.0-1.0 (åˆ†æç½®ä¿¡åº¦)
- cvss_score: 0.0-10.0 (CVSS v3è¯„åˆ†)
- description: è¯¦ç»†çš„æ¼æ´æè¿°
- impact: æ½œåœ¨å½±å“åˆ†æ
- remediation: å…·ä½“ä¿®å¤å»ºè®®
- false_positive_probability: 0.0-1.0 (è¯¯æŠ¥æ¦‚ç‡)
- references: ç›¸å…³å‚è€ƒèµ„æ–™åˆ—è¡¨

ç¡®ä¿åˆ†æçš„ä¸“ä¸šæ€§å’Œå®ç”¨æ€§ã€‚"""
    
    async def generate_report_summary(self, findings: List[Dict[str, Any]]) -> str:
        """ç”ŸæˆæŠ¥å‘Šæ‘˜è¦"""
        findings_summary = self._create_findings_summary(findings)
        
        prompt = f"""
è¯·åŸºäºä»¥ä¸‹æ¼æ´æ‰«æç»“æœç”Ÿæˆä¸€ä»½ä¸“ä¸šçš„å®‰å…¨è¯„ä¼°æŠ¥å‘Šæ‘˜è¦ï¼š

{findings_summary}

æŠ¥å‘Šæ‘˜è¦åº”åŒ…æ‹¬ï¼š
1. å®‰å…¨çŠ¶å†µæ€»è§ˆ
2. å…³é”®é£é™©è¯†åˆ«
3. ä¿®å¤ä¼˜å…ˆçº§å»ºè®®
4. æ•´ä½“å®‰å…¨è¯„çº§

è¯·ç”¨ç®€æ´ä¸“ä¸šçš„ä¸­æ–‡æ’°å†™ï¼Œé€‚åˆå‘æŠ€æœ¯å’Œç®¡ç†å±‚æ±‡æŠ¥ã€‚
"""
        
        try:
            message = await self.client.messages.create(
                model=self.config.model,
                max_tokens=1000,
                temperature=0.1,
                system="ä½ æ˜¯ä¸€åèµ„æ·±çš„ç½‘ç»œå®‰å…¨é¡¾é—®ï¼Œè´Ÿè´£ä¸ºå®¢æˆ·æ’°å†™ä¸“ä¸šçš„å®‰å…¨è¯„ä¼°æŠ¥å‘Šã€‚",
                messages=[{"role": "user", "content": prompt}]
            )
            
            return message.content[0].text
        except Exception as e:
            return f"ä½¿ç”¨Claudeç”ŸæˆæŠ¥å‘Šæ‘˜è¦å¤±è´¥: {e}"
    
    def _create_findings_summary(self, findings: List[Dict[str, Any]]) -> str:
        """åˆ›å»ºå‘ç°æ‘˜è¦"""
        if not findings:
            return "æœªå‘ç°å®‰å…¨é—®é¢˜"
        
        severity_counts = {}
        for finding in findings:
            severity = finding.get('severity', 'unknown')
            severity_counts[severity] = severity_counts.get(severity, 0) + 1
        
        summary = f"æ€»è®¡å‘ç° {len(findings)} ä¸ªå®‰å…¨é—®é¢˜ï¼š\n"
        for severity, count in severity_counts.items():
            summary += f"- {severity}: {count}ä¸ª\n"
        
        return summary
```

### Step 4: Ollamaæœ¬åœ°æ¨¡å‹æ”¯æŒ (0.5å¤©)

#### 4.1 Ollamaæä¾›å•†
```python
# vuln_scanner/core/ai/providers/ollama_provider.py
import aiohttp
import asyncio
from typing import Dict, List, Any
from ..base import AIProvider, VulnerabilityAnalysis, RiskLevel, AIProviderConfig

class OllamaProvider(AIProvider):
    """Ollamaæœ¬åœ°æ¨¡å‹æä¾›å•†"""
    
    def __init__(self, config: AIProviderConfig):
        super().__init__(config)
        self.base_url = config.base_url.rstrip('/')
        
    async def analyze_vulnerability(self, finding: Dict[str, Any]) -> VulnerabilityAnalysis:
        """ä½¿ç”¨Ollamaæœ¬åœ°æ¨¡å‹åˆ†ææ¼æ´"""
        prompt = self._create_vulnerability_prompt(finding)
        
        try:
            async with aiohttp.ClientSession() as session:
                payload = {
                    "model": self.config.model,
                    "prompt": prompt,
                    "system": self._get_system_prompt(),
                    "stream": False,
                    "options": {
                        "temperature": self.config.temperature,
                        "num_predict": self.config.max_tokens
                    }
                }
                
                async with session.post(
                    f"{self.base_url}/api/generate",
                    json=payload,
                    timeout=aiohttp.ClientTimeout(total=self.config.timeout)
                ) as response:
                    if response.status == 200:
                        result = await response.json()
                        analysis_text = result.get('response', '')
                        return self._parse_analysis_response(analysis_text)
                    else:
                        raise Exception(f"Ollama APIè¿”å›é”™è¯¯çŠ¶æ€: {response.status}")
                        
        except Exception as e:
            self.logger.error(f"Ollama APIè°ƒç”¨å¤±è´¥: {e}")
            raise
    
    async def health_check(self) -> bool:
        """æ£€æŸ¥OllamaæœåŠ¡çŠ¶æ€"""
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(
                    f"{self.base_url}/api/tags",
                    timeout=aiohttp.ClientTimeout(total=5)
                ) as response:
                    return response.status == 200
        except Exception:
            return False
```

## éªŒæ”¶æ ‡å‡†

### åŠŸèƒ½æ€§éªŒæ”¶
- [ ] **å¤šæä¾›å•†æ”¯æŒ**: OpenAIã€Claudeã€Ollamaå…¨éƒ¨å¯ç”¨
- [ ] **ç»Ÿä¸€æ¥å£**: æ‰€æœ‰æä¾›å•†å®ç°ç›¸åŒçš„APIæ¥å£
- [ ] **æ•…éšœè½¬ç§»**: ä¸»æä¾›å•†å¤±è´¥æ—¶è‡ªåŠ¨åˆ‡æ¢
- [ ] **é…ç½®çµæ´»**: æ”¯æŒbase_urlç­‰å‚æ•°é…ç½®

### AIåŠŸèƒ½éªŒæ”¶
```python
# AIåŠŸèƒ½æµ‹è¯•
ai_manager = AIManager(config.ai)

# æ¼æ´åˆ†ææµ‹è¯•
finding = {"type": "sql_injection", "target": "https://example.com"}
analysis = await ai_manager.analyze_vulnerability(finding)
assert analysis.severity in [RiskLevel.HIGH, RiskLevel.CRITICAL]
assert analysis.confidence > 0.8

# æŠ¥å‘Šç”Ÿæˆæµ‹è¯•
summary = await ai_manager.generate_report_summary([finding])
assert len(summary) > 100
assert "SQLæ³¨å…¥" in summary or "sql injection" in summary.lower()
```

### æ€§èƒ½éªŒæ”¶
- [ ] **å“åº”æ—¶é—´**: å•æ¬¡åˆ†æ < 30ç§’
- [ ] **å¹¶å‘å¤„ç†**: æ”¯æŒ3ä¸ªå¹¶å‘åˆ†æè¯·æ±‚
- [ ] **é”™è¯¯æ¢å¤**: APIå¤±è´¥åèƒ½è‡ªåŠ¨é‡è¯•
- [ ] **æˆæœ¬æ§åˆ¶**: Tokenä½¿ç”¨é‡ç›‘æ§

## äº¤ä»˜ç‰©

### æ ¸å¿ƒä»£ç 
- [ ] AIæä¾›å•†åŸºç±»å’Œæ¥å£å®šä¹‰
- [ ] OpenAIé€‚é…å™¨å®Œæ•´å®ç°
- [ ] Claudeé€‚é…å™¨å®Œæ•´å®ç°
- [ ] Ollamaé€‚é…å™¨å®ç°
- [ ] AIç®¡ç†å™¨å’Œæ•…éšœè½¬ç§»é€»è¾‘

### é…ç½®å’Œå·¥å…·
- [ ] AIæä¾›å•†é…ç½®æ¨¡æ¿
- [ ] APIå¯†é’¥ç®¡ç†æ–¹æ¡ˆ
- [ ] æˆæœ¬ç›‘æ§å·¥å…·
- [ ] å¥åº·æ£€æŸ¥è„šæœ¬

### æµ‹è¯•å’Œæ–‡æ¡£
- [ ] å®Œæ•´çš„AIæ¨¡å—æµ‹è¯•å¥—ä»¶
- [ ] Mockæä¾›å•†æµ‹è¯•å®ç°
- [ ] APIä½¿ç”¨æ–‡æ¡£å’Œç¤ºä¾‹
- [ ] æç¤ºè¯å·¥ç¨‹æŒ‡å—

## é£é™©ä¸ç¼“è§£

### é«˜é£é™©é¡¹
1. **APIæˆæœ¬æ§åˆ¶**: AIè°ƒç”¨è´¹ç”¨å¯èƒ½è¶…å‡ºé¢„ç®—
   - **ç¼“è§£**: å®ç°Tokenä½¿ç”¨é™åˆ¶å’Œæˆæœ¬ç›‘æ§
   - **å¤‡é€‰**: ä¼˜å…ˆä½¿ç”¨æœ¬åœ°æ¨¡å‹å’Œç¼“å­˜æœºåˆ¶

2. **APIç¨³å®šæ€§**: ç¬¬ä¸‰æ–¹AIæœåŠ¡å¯èƒ½ä¸ç¨³å®š
   - **ç¼“è§£**: å¤šæä¾›å•†æ•…éšœè½¬ç§»å’Œæœ¬åœ°å¤‡é€‰
   - **ç›‘æ§**: å®æ—¶å¥åº·æ£€æŸ¥å’Œé”™è¯¯ç›‘æ§

### ä¸­é£é™©é¡¹
1. **æç¤ºè¯è´¨é‡**: æç¤ºè¯è®¾è®¡å½±å“åˆ†æè´¨é‡
   - **ç¼“è§£**: åŸºäºæµ‹è¯•æ•°æ®ä¼˜åŒ–æç¤ºè¯
   - **éªŒè¯**: å»ºç«‹AIåˆ†æè´¨é‡è¯„ä¼°æœºåˆ¶

---
**ä»»åŠ¡è´Ÿè´£äºº**: AI Engineer  
**å®¡æ ¸äºº**: Security Expert  
**ä¾èµ–ä»»åŠ¡**: Task 001, 002  
**é¢„è®¡å·¥ä½œé‡**: 3å¤©  
**å…³é”®é‡Œç¨‹ç¢‘**: AIé›†æˆå®Œæˆï¼Œæ¼æ´åˆ†æå¯ç”¨