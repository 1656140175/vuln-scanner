"""Exploitation phase checkpoint strategy."""

import logging
from typing import Dict, List, Any
from .base import CheckpointStrategy
from ..models import ProgressState


logger = logging.getLogger(__name__)


class ExploitationCheckpointStrategy(CheckpointStrategy):
    """Checkpoint strategy for the exploitation phase."""
    
    async def create_checkpoint(self, phase_data: Dict[str, Any],
                              progress_state: ProgressState) -> Dict[str, Any]:
        """Create checkpoint for exploitation phase.
        
        The exploitation phase typically contains:
        - Proof of concept exploits
        - Exploitation attempts and results
        - Payload information
        - Access levels achieved
        - Post-exploitation data (limited for ethical reasons)
        """
        essential_data = self._extract_essential_data(phase_data)
        
        return {
            'phase_data': essential_data,
            'poc_exploits': essential_data.get('poc_exploits', {}),
            'exploitation_attempts': essential_data.get('exploitation_attempts', []),
            'successful_exploits': essential_data.get('successful_exploits', []),
            'failed_exploits': essential_data.get('failed_exploits', []),
            'payload_information': essential_data.get('payload_information', {}),
            'access_levels': essential_data.get('access_levels', {}),
            'exploitation_tools': essential_data.get('exploitation_tools', []),
            'ethical_boundaries': essential_data.get('ethical_boundaries', {}),
            'completion_status': {
                'poc_generation_complete': essential_data.get('poc_generation_complete', False),
                'exploit_validation_complete': essential_data.get('exploit_validation_complete', False),
                'impact_assessment_complete': essential_data.get('impact_assessment_complete', False),
                'cleanup_complete': essential_data.get('cleanup_complete', False),
            },
            'metadata': self.get_checkpoint_metadata(phase_data),
            'progress_snapshot': {
                'poc_exploits_created': len(essential_data.get('poc_exploits', {})),
                'successful_exploits': len(essential_data.get('successful_exploits', [])),
                'exploitation_attempts': len(essential_data.get('exploitation_attempts', [])),
                'phase_progress': progress_state.get_phase_progress(progress_state.current_phase).progress_percentage if progress_state.current_phase else 0
            },
            'security_notice': {
                'ethical_use_only': True,
                'authorized_testing': True,
                'no_malicious_intent': True,
                'cleanup_performed': essential_data.get('cleanup_complete', False)
            }
        }
    
    async def restore_checkpoint(self, checkpoint_data: Dict[str, Any]) -> Dict[str, Any]:
        """Restore exploitation phase data from checkpoint."""
        restored_data = {
            'poc_exploits': checkpoint_data.get('poc_exploits', {}),
            'exploitation_attempts': checkpoint_data.get('exploitation_attempts', []),
            'successful_exploits': checkpoint_data.get('successful_exploits', []),
            'failed_exploits': checkpoint_data.get('failed_exploits', []),
            'payload_information': checkpoint_data.get('payload_information', {}),
            'access_levels': checkpoint_data.get('access_levels', {}),
            'exploitation_tools': checkpoint_data.get('exploitation_tools', []),
            'ethical_boundaries': checkpoint_data.get('ethical_boundaries', {}),
            'poc_generation_complete': checkpoint_data.get('completion_status', {}).get('poc_generation_complete', False),
            'exploit_validation_complete': checkpoint_data.get('completion_status', {}).get('exploit_validation_complete', False),
            'impact_assessment_complete': checkpoint_data.get('completion_status', {}).get('impact_assessment_complete', False),
            'cleanup_complete': checkpoint_data.get('completion_status', {}).get('cleanup_complete', False),
            'resume_point': 'checkpoint_restored',
            'restored_at': checkpoint_data.get('metadata', {}).get('created_at'),
            'ethical_use_confirmed': True,  # Always confirm ethical use on restore
        }
        
        # Merge any additional phase data
        if 'phase_data' in checkpoint_data:
            restored_data.update(checkpoint_data['phase_data'])
        
        # Security validation on restore
        security_notice = checkpoint_data.get('security_notice', {})
        if not security_notice.get('ethical_use_only', False):
            logger.warning("Restored exploitation checkpoint without ethical use confirmation")
        
        logger.info(f"Restored exploitation phase: {len(restored_data.get('successful_exploits', []))} successful PoCs, "
                   f"{len(restored_data.get('poc_exploits', {}))} total PoCs created")
        
        return restored_data
    
    def validate_checkpoint(self, checkpoint_data: Dict[str, Any]) -> bool:
        """Validate exploitation phase checkpoint data."""
        required_keys = ['poc_exploits', 'exploitation_attempts', 'completion_status', 'metadata', 'security_notice']
        
        if not self._validate_essential_keys(checkpoint_data, required_keys):
            return False
        
        # Validate data types
        if not isinstance(checkpoint_data.get('poc_exploits'), dict):
            return False
        
        if not isinstance(checkpoint_data.get('exploitation_attempts'), list):
            return False
        
        if not isinstance(checkpoint_data.get('successful_exploits'), list):
            return False
        
        if not isinstance(checkpoint_data.get('completion_status'), dict):
            return False
        
        # Validate security notice
        security_notice = checkpoint_data.get('security_notice', {})
        if not isinstance(security_notice, dict):
            return False
        
        # Ensure ethical use confirmation
        if not security_notice.get('ethical_use_only', False):
            logger.error("Checkpoint validation failed: Missing ethical use confirmation")
            return False
        
        # Validate completion status structure
        completion_status = checkpoint_data.get('completion_status', {})
        required_completion_keys = [
            'poc_generation_complete', 'exploit_validation_complete',
            'impact_assessment_complete', 'cleanup_complete'
        ]
        
        for key in required_completion_keys:
            if key not in completion_status or not isinstance(completion_status[key], bool):
                return False
        
        # Validate exploit structure (basic check)
        for exploit in checkpoint_data.get('successful_exploits', []):
            if not isinstance(exploit, dict):
                return False
            if 'vulnerability_id' not in exploit or 'proof_of_concept' not in exploit:
                return False
        
        return True
    
    def _extract_essential_data(self, phase_data: Dict[str, Any]) -> Dict[str, Any]:
        """Extract essential exploitation phase data."""
        essential_keys = [
            'poc_exploits', 'exploitation_attempts', 'successful_exploits',
            'failed_exploits', 'payload_information', 'access_levels',
            'exploitation_tools', 'ethical_boundaries', 'poc_generation_complete',
            'exploit_validation_complete', 'impact_assessment_complete',
            'cleanup_complete', 'exploitation_metadata', 'exploitation_errors'
        ]
        
        essential_data = {}
        for key in essential_keys:
            if key in phase_data:
                essential_data[key] = phase_data[key]
        
        # Ensure ethical boundaries are always preserved
        if 'ethical_boundaries' not in essential_data:
            essential_data['ethical_boundaries'] = {
                'authorized_testing_only': True,
                'no_destructive_actions': True,
                'cleanup_required': True
            }
        
        return essential_data