"""Vulnerability scanning phase checkpoint strategy."""

import logging
from typing import Dict, List, Any
from .base import CheckpointStrategy
from ..models import ProgressState


logger = logging.getLogger(__name__)


class VulnerabilityCheckpointStrategy(CheckpointStrategy):
    """Checkpoint strategy for the vulnerability scanning phase."""
    
    async def create_checkpoint(self, phase_data: Dict[str, Any],
                              progress_state: ProgressState) -> Dict[str, Any]:
        """Create checkpoint for vulnerability scanning phase.
        
        The vulnerability scanning phase typically contains:
        - Vulnerability scan results
        - CVE information
        - Risk assessments
        - Scan tool outputs
        - False positive analysis
        """
        essential_data = self._extract_essential_data(phase_data)
        
        return {
            'phase_data': essential_data,
            'vulnerability_results': essential_data.get('vulnerability_results', {}),
            'cve_information': essential_data.get('cve_information', {}),
            'risk_assessments': essential_data.get('risk_assessments', {}),
            'scan_outputs': essential_data.get('scan_outputs', {}),
            'false_positives': essential_data.get('false_positives', []),
            'confirmed_vulnerabilities': essential_data.get('confirmed_vulnerabilities', []),
            'vulnerability_tools': essential_data.get('vulnerability_tools', []),
            'scan_coverage': essential_data.get('scan_coverage', {}),
            'completion_status': {
                'network_scan_complete': essential_data.get('network_scan_complete', False),
                'web_scan_complete': essential_data.get('web_scan_complete', False),
                'service_scan_complete': essential_data.get('service_scan_complete', False),
                'cve_analysis_complete': essential_data.get('cve_analysis_complete', False),
                'risk_assessment_complete': essential_data.get('risk_assessment_complete', False),
            },
            'metadata': self.get_checkpoint_metadata(phase_data),
            'progress_snapshot': {
                'vulnerabilities_found': len(essential_data.get('confirmed_vulnerabilities', [])),
                'false_positives_identified': len(essential_data.get('false_positives', [])),
                'cves_analyzed': len(essential_data.get('cve_information', {})),
                'scan_tools_used': len(essential_data.get('vulnerability_tools', [])),
                'phase_progress': progress_state.get_phase_progress(progress_state.current_phase).progress_percentage if progress_state.current_phase else 0
            }
        }
    
    async def restore_checkpoint(self, checkpoint_data: Dict[str, Any]) -> Dict[str, Any]:
        """Restore vulnerability scanning phase data from checkpoint."""
        restored_data = {
            'vulnerability_results': checkpoint_data.get('vulnerability_results', {}),
            'cve_information': checkpoint_data.get('cve_information', {}),
            'risk_assessments': checkpoint_data.get('risk_assessments', {}),
            'scan_outputs': checkpoint_data.get('scan_outputs', {}),
            'false_positives': checkpoint_data.get('false_positives', []),
            'confirmed_vulnerabilities': checkpoint_data.get('confirmed_vulnerabilities', []),
            'vulnerability_tools': checkpoint_data.get('vulnerability_tools', []),
            'scan_coverage': checkpoint_data.get('scan_coverage', {}),
            'network_scan_complete': checkpoint_data.get('completion_status', {}).get('network_scan_complete', False),
            'web_scan_complete': checkpoint_data.get('completion_status', {}).get('web_scan_complete', False),
            'service_scan_complete': checkpoint_data.get('completion_status', {}).get('service_scan_complete', False),
            'cve_analysis_complete': checkpoint_data.get('completion_status', {}).get('cve_analysis_complete', False),
            'risk_assessment_complete': checkpoint_data.get('completion_status', {}).get('risk_assessment_complete', False),
            'resume_point': 'checkpoint_restored',
            'restored_at': checkpoint_data.get('metadata', {}).get('created_at'),
        }
        
        # Merge any additional phase data
        if 'phase_data' in checkpoint_data:
            restored_data.update(checkpoint_data['phase_data'])
        
        logger.info(f"Restored vulnerability scanning phase: {len(restored_data.get('confirmed_vulnerabilities', []))} vulnerabilities, "
                   f"{len(restored_data.get('false_positives', []))} false positives, "
                   f"{len(restored_data.get('cve_information', {}))} CVEs analyzed")
        
        return restored_data
    
    def validate_checkpoint(self, checkpoint_data: Dict[str, Any]) -> bool:
        """Validate vulnerability scanning phase checkpoint data."""
        required_keys = ['vulnerability_results', 'confirmed_vulnerabilities', 'completion_status', 'metadata']
        
        if not self._validate_essential_keys(checkpoint_data, required_keys):
            return False
        
        # Validate data types
        if not isinstance(checkpoint_data.get('vulnerability_results'), dict):
            return False
        
        if not isinstance(checkpoint_data.get('confirmed_vulnerabilities'), list):
            return False
        
        if not isinstance(checkpoint_data.get('false_positives'), list):
            return False
        
        if not isinstance(checkpoint_data.get('cve_information'), dict):
            return False
        
        if not isinstance(checkpoint_data.get('completion_status'), dict):
            return False
        
        # Validate completion status structure
        completion_status = checkpoint_data.get('completion_status', {})
        required_completion_keys = [
            'network_scan_complete', 'web_scan_complete', 'service_scan_complete',
            'cve_analysis_complete', 'risk_assessment_complete'
        ]
        
        for key in required_completion_keys:
            if key not in completion_status or not isinstance(completion_status[key], bool):
                return False
        
        # Validate vulnerability structure (basic check)
        for vuln in checkpoint_data.get('confirmed_vulnerabilities', []):
            if not isinstance(vuln, dict):
                return False
            if 'severity' not in vuln or 'description' not in vuln:
                return False
        
        return True
    
    def _extract_essential_data(self, phase_data: Dict[str, Any]) -> Dict[str, Any]:
        """Extract essential vulnerability scanning phase data."""
        essential_keys = [
            'vulnerability_results', 'cve_information', 'risk_assessments',
            'scan_outputs', 'false_positives', 'confirmed_vulnerabilities',
            'vulnerability_tools', 'scan_coverage', 'network_scan_complete',
            'web_scan_complete', 'service_scan_complete', 'cve_analysis_complete',
            'risk_assessment_complete', 'vuln_scan_metadata', 'vuln_scan_errors'
        ]
        
        essential_data = {}
        for key in essential_keys:
            if key in phase_data:
                essential_data[key] = phase_data[key]
        
        return essential_data